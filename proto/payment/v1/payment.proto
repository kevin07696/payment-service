syntax = "proto3";

package payment.v1;

option go_package = "github.com/kevin07696/payment-service/proto/payment/v1;paymentv1";

import "google/protobuf/timestamp.proto";
import "google/api/annotations.proto";

// PaymentService handles all payment operations
service PaymentService {
  // Authorize holds funds on a payment method without capturing
  rpc Authorize(AuthorizeRequest) returns (PaymentResponse) {
    option (google.api.http) = {
      post: "/api/v1/payments/authorize"
      body: "*"
    };
  }

  // Capture completes a previously authorized payment
  rpc Capture(CaptureRequest) returns (PaymentResponse) {
    option (google.api.http) = {
      post: "/api/v1/payments/capture"
      body: "*"
    };
  }

  // Sale combines authorize and capture in one operation
  rpc Sale(SaleRequest) returns (PaymentResponse) {
    option (google.api.http) = {
      post: "/api/v1/payments/sale"
      body: "*"
    };
  }

  // Void cancels an authorized or captured payment
  rpc Void(VoidRequest) returns (PaymentResponse) {
    option (google.api.http) = {
      post: "/api/v1/payments/void"
      body: "*"
    };
  }

  // Refund returns funds to the customer
  rpc Refund(RefundRequest) returns (PaymentResponse) {
    option (google.api.http) = {
      post: "/api/v1/payments/refund"
      body: "*"
    };
  }

  // GetTransaction retrieves transaction details
  rpc GetTransaction(GetTransactionRequest) returns (Transaction) {
    option (google.api.http) = {
      get: "/api/v1/payments/{transaction_id}"
    };
  }

  // ListTransactions lists transactions for a merchant or customer
  rpc ListTransactions(ListTransactionsRequest) returns (ListTransactionsResponse) {
    option (google.api.http) = {
      get: "/api/v1/payments"
    };
  }
}

// AuthorizeRequest authorizes a payment without capturing
message AuthorizeRequest {
  string merchant_id = 1; // Multi-tenant: which agent/merchant
  string customer_id = 2; // Customer ID (nullable for guest transactions)
  string amount = 3; // Decimal as string (e.g., "29.99")
  string currency = 4; // ISO 4217 code (e.g., "USD")

  // Payment method - exactly one required
  oneof payment_method {
    string payment_method_id = 5; // UUID of saved payment method
    string payment_token = 6; // EPX token (AUTH_GUID/BRIC) for one-time use
  }

  string idempotency_key = 7;
  map<string, string> metadata = 8;
}

// CaptureRequest captures a previously authorized payment
message CaptureRequest {
  string transaction_id = 1; // Original authorization transaction ID
  string amount = 2; // Optional: partial capture amount
  string idempotency_key = 3;
}

// SaleRequest combines authorize and capture
message SaleRequest {
  string merchant_id = 1;
  string customer_id = 2; // Nullable for guest transactions
  string amount = 3; // Decimal as string
  string currency = 4;

  // Payment method - exactly one required
  oneof payment_method {
    string payment_method_id = 5; // UUID of saved payment method
    string payment_token = 6; // EPX token (AUTH_GUID/BRIC) for one-time use
  }

  string idempotency_key = 7;
  map<string, string> metadata = 8;
}

// VoidRequest cancels an authorized or captured payment
message VoidRequest {
  string group_id = 1; // Transaction group to void
  string idempotency_key = 2;
}

// RefundRequest refunds a captured payment
message RefundRequest {
  string group_id = 1; // Transaction group to refund
  string amount = 2; // Optional: partial refund amount
  string reason = 3;
  string idempotency_key = 4;
}

// GetTransactionRequest retrieves a transaction
message GetTransactionRequest {
  string transaction_id = 1;
}

// ListTransactionsRequest lists transactions
message ListTransactionsRequest {
  string merchant_id = 1;
  string customer_id = 2; // Optional: filter by customer
  string group_id = 3; // Optional: get all transactions in a group
  TransactionStatus status = 4; // Optional: filter by status
  int32 limit = 5; // Default: 100
  int32 offset = 6;
}

// ListTransactionsResponse contains transaction list
message ListTransactionsResponse {
  repeated Transaction transactions = 1;
  int32 total_count = 2;
}

// CardInfo contains abstracted card information for receipts
message CardInfo {
  string brand = 1;      // "visa", "mastercard", "amex", "discover"
  string last_four = 2;  // Last 4 digits
}

// PaymentResponse is returned from payment operations
// Clean, gateway-agnostic receipt data
message PaymentResponse {
  // Identifiers
  string transaction_id = 1;
  string group_id = 2; // Links all related transactions (store this for refunds/voids)

  // Receipt display
  string amount = 3;
  string currency = 4;
  TransactionStatus status = 5;
  TransactionType type = 6;
  bool is_approved = 7;

  // Receipt details (abstracted from gateway)
  string authorization_code = 8;  // Bank authorization code
  string message = 9;              // "Approved", "Insufficient funds", etc.

  // Card info (for display only, no tokens)
  CardInfo card = 10;

  google.protobuf.Timestamp created_at = 11;
}

// Transaction represents a complete transaction record
// Clean, gateway-agnostic transaction data
message Transaction {
  string id = 1;
  string group_id = 2; // Links related transactions (auth → capture → refund)
  string merchant_id = 3;
  string customer_id = 4; // Nullable for guest transactions
  string amount = 5;
  string currency = 6;
  TransactionStatus status = 7;
  TransactionType type = 8;
  PaymentMethodType payment_method_type = 9;
  string payment_method_id = 10; // Saved payment method used (if any)

  // Receipt details (abstracted from gateway)
  string authorization_code = 11; // Bank authorization code
  string message = 12;             // Response message

  // Card info (for display)
  CardInfo card = 13;

  string idempotency_key = 14;
  google.protobuf.Timestamp created_at = 15;
  google.protobuf.Timestamp updated_at = 16;
}

// TransactionStatus represents the outcome of a transaction (success/failure)
// Based on gateway response (EPX: auth_resp='00' = approved, else = failed)
// Note: This is NOT the transaction lifecycle state - use 'type' field for that
enum TransactionStatus {
  TRANSACTION_STATUS_UNSPECIFIED = 0;
  TRANSACTION_STATUS_APPROVED = 1;   // Gateway approved (auth_resp='00')
  TRANSACTION_STATUS_DECLINED = 2;   // Gateway declined (auth_resp != '00')
}

// TransactionType represents the type of transaction
// Matches database constraint: ('charge', 'refund', 'void', 'pre_note', 'auth', 'capture')
enum TransactionType {
  TRANSACTION_TYPE_UNSPECIFIED = 0;
  TRANSACTION_TYPE_AUTH = 1; // Authorization only
  TRANSACTION_TYPE_CAPTURE = 2; // Capture authorized funds
  TRANSACTION_TYPE_CHARGE = 3; // Combined auth + capture (sale)
  TRANSACTION_TYPE_REFUND = 4; // Return funds
  TRANSACTION_TYPE_VOID = 5; // Cancel transaction before settlement
  TRANSACTION_TYPE_PRE_NOTE = 6; // ACH verification
}

// PaymentMethodType represents the payment method used
enum PaymentMethodType {
  PAYMENT_METHOD_TYPE_UNSPECIFIED = 0;
  PAYMENT_METHOD_TYPE_CREDIT_CARD = 1;
  PAYMENT_METHOD_TYPE_ACH = 2;
}
