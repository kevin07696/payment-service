-- +goose Up
-- +goose StatementBegin

-- Enable pg_cron extension (requires superuser or rds_superuser on AWS RDS)
-- NOTE: On AWS RDS, you need to add pg_cron to shared_preload_libraries parameter
-- and restart the database instance before running this migration.
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Grant usage on cron schema
GRANT USAGE ON SCHEMA cron TO postgres;

-- =============================================================================
-- Subscription Billing Cron Job
-- =============================================================================

-- Function to process subscription billing
CREATE OR REPLACE FUNCTION process_subscription_billing()
RETURNS TABLE(
    processed_count INT,
    success_count INT,
    failure_count INT,
    error_messages TEXT[]
) AS $$
DECLARE
    v_subscription RECORD;
    v_processed INT := 0;
    v_success INT := 0;
    v_failure INT := 0;
    v_errors TEXT[] := ARRAY[]::TEXT[];
    v_error_msg TEXT;
BEGIN
    -- Get subscriptions due for billing (next_billing_date <= today and status = 'active')
    FOR v_subscription IN
        SELECT *
        FROM subscriptions
        WHERE next_billing_date <= CURRENT_DATE
          AND status = 'active'
          AND deleted_at IS NULL
        LIMIT 100 -- Process 100 at a time to avoid long-running transactions
    LOOP
        v_processed := v_processed + 1;

        BEGIN
            -- NOTE: This is a simplified version. In production, this would:
            -- 1. Call EPX API via Server Post to charge the payment method
            -- 2. Create a transaction record
            -- 3. Update subscription with next billing date
            -- 4. Handle retries and failures
            --
            -- For now, we just log that billing was attempted.
            -- The actual billing logic should be handled by the application layer
            -- via the HTTP cron endpoint or through a database trigger/procedure
            -- that calls out to the EPX API.

            -- Placeholder: Mark as processed by incrementing next billing date
            UPDATE subscriptions
            SET
                next_billing_date = CASE interval_unit
                    WHEN 'day' THEN next_billing_date + (interval_value || ' days')::INTERVAL
                    WHEN 'week' THEN next_billing_date + ((interval_value * 7) || ' days')::INTERVAL
                    WHEN 'month' THEN next_billing_date + (interval_value || ' months')::INTERVAL
                    WHEN 'year' THEN next_billing_date + (interval_value || ' years')::INTERVAL
                    ELSE next_billing_date + '1 month'::INTERVAL
                END,
                failure_retry_count = 0,
                updated_at = CURRENT_TIMESTAMP
            WHERE id = v_subscription.id;

            v_success := v_success + 1;

        EXCEPTION WHEN OTHERS THEN
            v_failure := v_failure + 1;
            GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT;
            v_errors := array_append(v_errors, 'Subscription ' || v_subscription.id::TEXT || ': ' || v_error_msg);

            -- Increment failure count
            UPDATE subscriptions
            SET
                failure_retry_count = failure_retry_count + 1,
                status = CASE
                    WHEN failure_retry_count + 1 >= max_retries THEN 'past_due'
                    ELSE 'active'
                END,
                updated_at = CURRENT_TIMESTAMP
            WHERE id = v_subscription.id;
        END;
    END LOOP;

    -- Return results
    RETURN QUERY SELECT v_processed, v_success, v_failure, v_errors;
END;
$$ LANGUAGE plpgsql;

-- Schedule billing processing to run daily at 2 AM UTC
-- NOTE: This creates the cron job. To enable/disable, use cron.schedule/cron.unschedule
SELECT cron.schedule(
    'process-subscription-billing',  -- job name
    '0 2 * * *',                      -- cron expression: daily at 2 AM UTC
    $$SELECT * FROM process_subscription_billing();$$
);

-- =============================================================================
-- Dispute Sync Cron Job
-- =============================================================================

-- Function to sync disputes from North API
CREATE OR REPLACE FUNCTION sync_disputes_placeholder()
RETURNS TABLE(
    agents_processed INT,
    new_chargebacks INT,
    updated_chargebacks INT,
    error_messages TEXT[]
) AS $$
BEGIN
    -- NOTE: This is a placeholder function.
    -- Actual dispute syncing requires calling the North API via HTTP,
    -- which should be done by the application layer (not pure SQL/plpgsql).
    --
    -- Use the HTTP cron endpoint /cron/sync-disputes for actual syncing.
    --
    -- This function exists as a stub for pg_cron scheduling purposes.
    -- It could be enhanced with pg_net extension to make HTTP calls from PostgreSQL.

    RAISE NOTICE 'Dispute sync should be handled via HTTP endpoint: POST /cron/sync-disputes';

    RETURN QUERY SELECT 0, 0, 0, ARRAY['Use HTTP endpoint for actual sync']::TEXT[];
END;
$$ LANGUAGE plpgsql;

-- Schedule dispute sync to run daily at 3 AM UTC
SELECT cron.schedule(
    'sync-disputes',           -- job name
    '0 3 * * *',              -- cron expression: daily at 3 AM UTC
    $$SELECT * FROM sync_disputes_placeholder();$$
);

-- =============================================================================
-- View cron job status
-- =============================================================================

-- View to check cron job history
COMMENT ON VIEW cron.job_run_details IS 'View cron job execution history';

-- Function to check last run of each job
CREATE OR REPLACE FUNCTION get_cron_job_status()
RETURNS TABLE(
    jobid BIGINT,
    jobname TEXT,
    schedule TEXT,
    active BOOLEAN,
    last_run_time TIMESTAMPTZ,
    last_run_status TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        j.jobid,
        j.jobname,
        j.schedule,
        j.active,
        r.start_time AS last_run_time,
        CASE
            WHEN r.status = 'succeeded' THEN 'Success'
            WHEN r.status = 'failed' THEN 'Failed: ' || COALESCE(r.return_message, 'Unknown error')
            ELSE 'Unknown'
        END AS last_run_status
    FROM cron.job j
    LEFT JOIN LATERAL (
        SELECT start_time, status, return_message
        FROM cron.job_run_details
        WHERE jobid = j.jobid
        ORDER BY start_time DESC
        LIMIT 1
    ) r ON true
    ORDER BY j.jobid;
END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- Manual cron job management functions
-- =============================================================================

-- Function to manually trigger subscription billing
-- Manually trigger subscription billing processing.
-- Returns: (processed_count, success_count, failure_count, error_messages).
-- Usage: SELECT * FROM process_subscription_billing();

-- Function to disable/enable cron jobs
CREATE OR REPLACE FUNCTION disable_cron_job(job_name TEXT)
RETURNS VOID AS $$
BEGIN
    UPDATE cron.job SET active = FALSE WHERE jobname = job_name;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION enable_cron_job(job_name TEXT)
RETURNS VOID AS $$
BEGIN
    UPDATE cron.job SET active = TRUE WHERE jobname = job_name;
END;
$$ LANGUAGE plpgsql;

-- +goose StatementEnd

-- +goose Down
-- +goose StatementBegin

-- Remove cron jobs
SELECT cron.unschedule('process-subscription-billing');
SELECT cron.unschedule('sync-disputes');

-- Drop functions
DROP FUNCTION IF EXISTS process_subscription_billing();
DROP FUNCTION IF EXISTS sync_disputes_placeholder();
DROP FUNCTION IF EXISTS get_cron_job_status();
DROP FUNCTION IF EXISTS disable_cron_job(TEXT);
DROP FUNCTION IF EXISTS enable_cron_job(TEXT);

-- Drop extension (commented out to avoid issues with other databases using it)
-- DROP EXTENSION IF EXISTS pg_cron;

-- +goose StatementEnd
