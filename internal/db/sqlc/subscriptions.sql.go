// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: subscriptions.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelSubscription = `-- name: CancelSubscription :one
UPDATE subscriptions
SET status = $1, cancelled_at = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $3
RETURNING id, merchant_id, customer_id, amount_cents, currency, interval_value, interval_unit, status, payment_method_id, next_billing_date, failure_retry_count, max_retries, gateway_subscription_id, metadata, deleted_at, created_at, updated_at, cancelled_at
`

type CancelSubscriptionParams struct {
	Status     string             `json:"status"`
	CanceledAt pgtype.Timestamptz `json:"canceled_at"`
	ID         uuid.UUID          `json:"id"`
}

func (q *Queries) CancelSubscription(ctx context.Context, arg CancelSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, cancelSubscription, arg.Status, arg.CanceledAt, arg.ID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CustomerID,
		&i.AmountCents,
		&i.Currency,
		&i.IntervalValue,
		&i.IntervalUnit,
		&i.Status,
		&i.PaymentMethodID,
		&i.NextBillingDate,
		&i.FailureRetryCount,
		&i.MaxRetries,
		&i.GatewaySubscriptionID,
		&i.Metadata,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CancelledAt,
	)
	return i, err
}

const countSubscriptions = `-- name: CountSubscriptions :one
SELECT COUNT(*) FROM subscriptions
WHERE
    ($1::uuid IS NULL OR merchant_id = $1) AND
    ($2::uuid IS NULL OR customer_id = $2) AND
    ($3::varchar IS NULL OR status = $3)
`

type CountSubscriptionsParams struct {
	MerchantID pgtype.UUID `json:"merchant_id"`
	CustomerID pgtype.UUID `json:"customer_id"`
	Status     pgtype.Text `json:"status"`
}

func (q *Queries) CountSubscriptions(ctx context.Context, arg CountSubscriptionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSubscriptions, arg.MerchantID, arg.CustomerID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (
    id, merchant_id, customer_id, amount_cents, currency,
    interval_value, interval_unit, status,
    payment_method_id, next_billing_date,
    failure_retry_count, max_retries,
    gateway_subscription_id, metadata
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8,
    $9, $10,
    $11, $12,
    $13, $14
) RETURNING id, merchant_id, customer_id, amount_cents, currency, interval_value, interval_unit, status, payment_method_id, next_billing_date, failure_retry_count, max_retries, gateway_subscription_id, metadata, deleted_at, created_at, updated_at, cancelled_at
`

type CreateSubscriptionParams struct {
	ID                    uuid.UUID   `json:"id"`
	MerchantID            uuid.UUID   `json:"merchant_id"`
	CustomerID            uuid.UUID   `json:"customer_id"`
	AmountCents           int64       `json:"amount_cents"`
	Currency              string      `json:"currency"`
	IntervalValue         int32       `json:"interval_value"`
	IntervalUnit          string      `json:"interval_unit"`
	Status                string      `json:"status"`
	PaymentMethodID       uuid.UUID   `json:"payment_method_id"`
	NextBillingDate       pgtype.Date `json:"next_billing_date"`
	FailureRetryCount     int32       `json:"failure_retry_count"`
	MaxRetries            int32       `json:"max_retries"`
	GatewaySubscriptionID pgtype.Text `json:"gateway_subscription_id"`
	Metadata              []byte      `json:"metadata"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.ID,
		arg.MerchantID,
		arg.CustomerID,
		arg.AmountCents,
		arg.Currency,
		arg.IntervalValue,
		arg.IntervalUnit,
		arg.Status,
		arg.PaymentMethodID,
		arg.NextBillingDate,
		arg.FailureRetryCount,
		arg.MaxRetries,
		arg.GatewaySubscriptionID,
		arg.Metadata,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CustomerID,
		&i.AmountCents,
		&i.Currency,
		&i.IntervalValue,
		&i.IntervalUnit,
		&i.Status,
		&i.PaymentMethodID,
		&i.NextBillingDate,
		&i.FailureRetryCount,
		&i.MaxRetries,
		&i.GatewaySubscriptionID,
		&i.Metadata,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CancelledAt,
	)
	return i, err
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, merchant_id, customer_id, amount_cents, currency, interval_value, interval_unit, status, payment_method_id, next_billing_date, failure_retry_count, max_retries, gateway_subscription_id, metadata, deleted_at, created_at, updated_at, cancelled_at FROM subscriptions
WHERE id = $1
`

func (q *Queries) GetSubscriptionByID(ctx context.Context, id uuid.UUID) (Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByID, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CustomerID,
		&i.AmountCents,
		&i.Currency,
		&i.IntervalValue,
		&i.IntervalUnit,
		&i.Status,
		&i.PaymentMethodID,
		&i.NextBillingDate,
		&i.FailureRetryCount,
		&i.MaxRetries,
		&i.GatewaySubscriptionID,
		&i.Metadata,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CancelledAt,
	)
	return i, err
}

const incrementSubscriptionFailureCount = `-- name: IncrementSubscriptionFailureCount :one
UPDATE subscriptions
SET
    failure_retry_count = $1,
    status = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $3
RETURNING id, merchant_id, customer_id, amount_cents, currency, interval_value, interval_unit, status, payment_method_id, next_billing_date, failure_retry_count, max_retries, gateway_subscription_id, metadata, deleted_at, created_at, updated_at, cancelled_at
`

type IncrementSubscriptionFailureCountParams struct {
	FailureRetryCount int32     `json:"failure_retry_count"`
	Status            string    `json:"status"`
	ID                uuid.UUID `json:"id"`
}

func (q *Queries) IncrementSubscriptionFailureCount(ctx context.Context, arg IncrementSubscriptionFailureCountParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, incrementSubscriptionFailureCount, arg.FailureRetryCount, arg.Status, arg.ID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CustomerID,
		&i.AmountCents,
		&i.Currency,
		&i.IntervalValue,
		&i.IntervalUnit,
		&i.Status,
		&i.PaymentMethodID,
		&i.NextBillingDate,
		&i.FailureRetryCount,
		&i.MaxRetries,
		&i.GatewaySubscriptionID,
		&i.Metadata,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CancelledAt,
	)
	return i, err
}

const incrementSubscriptionRetryCount = `-- name: IncrementSubscriptionRetryCount :exec
UPDATE subscriptions
SET failure_retry_count = failure_retry_count + 1, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) IncrementSubscriptionRetryCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementSubscriptionRetryCount, id)
	return err
}

const listDueSubscriptions = `-- name: ListDueSubscriptions :many
SELECT id, merchant_id, customer_id, amount_cents, currency, interval_value, interval_unit, status, payment_method_id, next_billing_date, failure_retry_count, max_retries, gateway_subscription_id, metadata, deleted_at, created_at, updated_at, cancelled_at FROM subscriptions
WHERE status = 'active' AND next_billing_date <= $1
ORDER BY next_billing_date ASC
LIMIT $2
`

type ListDueSubscriptionsParams struct {
	AsOfDate pgtype.Date `json:"as_of_date"`
	LimitVal int32       `json:"limit_val"`
}

func (q *Queries) ListDueSubscriptions(ctx context.Context, arg ListDueSubscriptionsParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listDueSubscriptions, arg.AsOfDate, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.CustomerID,
			&i.AmountCents,
			&i.Currency,
			&i.IntervalValue,
			&i.IntervalUnit,
			&i.Status,
			&i.PaymentMethodID,
			&i.NextBillingDate,
			&i.FailureRetryCount,
			&i.MaxRetries,
			&i.GatewaySubscriptionID,
			&i.Metadata,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptions = `-- name: ListSubscriptions :many
SELECT id, merchant_id, customer_id, amount_cents, currency, interval_value, interval_unit, status, payment_method_id, next_billing_date, failure_retry_count, max_retries, gateway_subscription_id, metadata, deleted_at, created_at, updated_at, cancelled_at FROM subscriptions
WHERE
    ($1::uuid IS NULL OR merchant_id = $1) AND
    ($2::uuid IS NULL OR customer_id = $2) AND
    ($3::varchar IS NULL OR status = $3)
ORDER BY created_at DESC
LIMIT $5 OFFSET $4
`

type ListSubscriptionsParams struct {
	MerchantID pgtype.UUID `json:"merchant_id"`
	CustomerID pgtype.UUID `json:"customer_id"`
	Status     pgtype.Text `json:"status"`
	OffsetVal  int32       `json:"offset_val"`
	LimitVal   int32       `json:"limit_val"`
}

func (q *Queries) ListSubscriptions(ctx context.Context, arg ListSubscriptionsParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptions,
		arg.MerchantID,
		arg.CustomerID,
		arg.Status,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.CustomerID,
			&i.AmountCents,
			&i.Currency,
			&i.IntervalValue,
			&i.IntervalUnit,
			&i.Status,
			&i.PaymentMethodID,
			&i.NextBillingDate,
			&i.FailureRetryCount,
			&i.MaxRetries,
			&i.GatewaySubscriptionID,
			&i.Metadata,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsByCustomer = `-- name: ListSubscriptionsByCustomer :many
SELECT id, merchant_id, customer_id, amount_cents, currency, interval_value, interval_unit, status, payment_method_id, next_billing_date, failure_retry_count, max_retries, gateway_subscription_id, metadata, deleted_at, created_at, updated_at, cancelled_at FROM subscriptions
WHERE merchant_id = $1 AND customer_id = $2
ORDER BY created_at DESC
`

type ListSubscriptionsByCustomerParams struct {
	MerchantID uuid.UUID `json:"merchant_id"`
	CustomerID uuid.UUID `json:"customer_id"`
}

func (q *Queries) ListSubscriptionsByCustomer(ctx context.Context, arg ListSubscriptionsByCustomerParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsByCustomer, arg.MerchantID, arg.CustomerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.CustomerID,
			&i.AmountCents,
			&i.Currency,
			&i.IntervalValue,
			&i.IntervalUnit,
			&i.Status,
			&i.PaymentMethodID,
			&i.NextBillingDate,
			&i.FailureRetryCount,
			&i.MaxRetries,
			&i.GatewaySubscriptionID,
			&i.Metadata,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsDueForBilling = `-- name: ListSubscriptionsDueForBilling :many
SELECT id, merchant_id, customer_id, amount_cents, currency, interval_value, interval_unit, status, payment_method_id, next_billing_date, failure_retry_count, max_retries, gateway_subscription_id, metadata, deleted_at, created_at, updated_at, cancelled_at FROM subscriptions
WHERE status = 'active' AND next_billing_date <= $1
ORDER BY next_billing_date ASC
LIMIT $2
`

type ListSubscriptionsDueForBillingParams struct {
	NextBillingDate pgtype.Date `json:"next_billing_date"`
	LimitVal        int32       `json:"limit_val"`
}

func (q *Queries) ListSubscriptionsDueForBilling(ctx context.Context, arg ListSubscriptionsDueForBillingParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsDueForBilling, arg.NextBillingDate, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.CustomerID,
			&i.AmountCents,
			&i.Currency,
			&i.IntervalValue,
			&i.IntervalUnit,
			&i.Status,
			&i.PaymentMethodID,
			&i.NextBillingDate,
			&i.FailureRetryCount,
			&i.MaxRetries,
			&i.GatewaySubscriptionID,
			&i.Metadata,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetSubscriptionRetryCount = `-- name: ResetSubscriptionRetryCount :exec
UPDATE subscriptions
SET failure_retry_count = 0, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) ResetSubscriptionRetryCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, resetSubscriptionRetryCount, id)
	return err
}

const updateNextBillingDate = `-- name: UpdateNextBillingDate :exec
UPDATE subscriptions
SET next_billing_date = $1, updated_at = CURRENT_TIMESTAMP
WHERE id = $2
`

type UpdateNextBillingDateParams struct {
	NextBillingDate pgtype.Date `json:"next_billing_date"`
	ID              uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateNextBillingDate(ctx context.Context, arg UpdateNextBillingDateParams) error {
	_, err := q.db.Exec(ctx, updateNextBillingDate, arg.NextBillingDate, arg.ID)
	return err
}

const updateSubscription = `-- name: UpdateSubscription :one
UPDATE subscriptions
SET
    amount_cents = $1,
    interval_value = $2,
    interval_unit = $3,
    payment_method_id = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $5
RETURNING id, merchant_id, customer_id, amount_cents, currency, interval_value, interval_unit, status, payment_method_id, next_billing_date, failure_retry_count, max_retries, gateway_subscription_id, metadata, deleted_at, created_at, updated_at, cancelled_at
`

type UpdateSubscriptionParams struct {
	AmountCents     int64     `json:"amount_cents"`
	IntervalValue   int32     `json:"interval_value"`
	IntervalUnit    string    `json:"interval_unit"`
	PaymentMethodID uuid.UUID `json:"payment_method_id"`
	ID              uuid.UUID `json:"id"`
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscription,
		arg.AmountCents,
		arg.IntervalValue,
		arg.IntervalUnit,
		arg.PaymentMethodID,
		arg.ID,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CustomerID,
		&i.AmountCents,
		&i.Currency,
		&i.IntervalValue,
		&i.IntervalUnit,
		&i.Status,
		&i.PaymentMethodID,
		&i.NextBillingDate,
		&i.FailureRetryCount,
		&i.MaxRetries,
		&i.GatewaySubscriptionID,
		&i.Metadata,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CancelledAt,
	)
	return i, err
}

const updateSubscriptionBilling = `-- name: UpdateSubscriptionBilling :one
UPDATE subscriptions
SET
    next_billing_date = $1,
    failure_retry_count = $2,
    status = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $4
RETURNING id, merchant_id, customer_id, amount_cents, currency, interval_value, interval_unit, status, payment_method_id, next_billing_date, failure_retry_count, max_retries, gateway_subscription_id, metadata, deleted_at, created_at, updated_at, cancelled_at
`

type UpdateSubscriptionBillingParams struct {
	NextBillingDate   pgtype.Date `json:"next_billing_date"`
	FailureRetryCount int32       `json:"failure_retry_count"`
	Status            string      `json:"status"`
	ID                uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateSubscriptionBilling(ctx context.Context, arg UpdateSubscriptionBillingParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionBilling,
		arg.NextBillingDate,
		arg.FailureRetryCount,
		arg.Status,
		arg.ID,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CustomerID,
		&i.AmountCents,
		&i.Currency,
		&i.IntervalValue,
		&i.IntervalUnit,
		&i.Status,
		&i.PaymentMethodID,
		&i.NextBillingDate,
		&i.FailureRetryCount,
		&i.MaxRetries,
		&i.GatewaySubscriptionID,
		&i.Metadata,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CancelledAt,
	)
	return i, err
}

const updateSubscriptionStatus = `-- name: UpdateSubscriptionStatus :one
UPDATE subscriptions
SET status = $1, updated_at = CURRENT_TIMESTAMP
WHERE id = $2
RETURNING id, merchant_id, customer_id, amount_cents, currency, interval_value, interval_unit, status, payment_method_id, next_billing_date, failure_retry_count, max_retries, gateway_subscription_id, metadata, deleted_at, created_at, updated_at, cancelled_at
`

type UpdateSubscriptionStatusParams struct {
	Status string    `json:"status"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) UpdateSubscriptionStatus(ctx context.Context, arg UpdateSubscriptionStatusParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionStatus, arg.Status, arg.ID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CustomerID,
		&i.AmountCents,
		&i.Currency,
		&i.IntervalValue,
		&i.IntervalUnit,
		&i.Status,
		&i.PaymentMethodID,
		&i.NextBillingDate,
		&i.FailureRetryCount,
		&i.MaxRetries,
		&i.GatewaySubscriptionID,
		&i.Metadata,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CancelledAt,
	)
	return i, err
}
