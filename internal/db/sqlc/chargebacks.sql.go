// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chargebacks.sql

package sqlc

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addEvidenceFile = `-- name: AddEvidenceFile :exec
UPDATE chargebacks
SET evidence_files = array_append(evidence_files, $1), updated_at = CURRENT_TIMESTAMP
WHERE id = $2
`

type AddEvidenceFileParams struct {
	FileUrl interface{} `json:"file_url"`
	ID      uuid.UUID   `json:"id"`
}

func (q *Queries) AddEvidenceFile(ctx context.Context, arg AddEvidenceFileParams) error {
	_, err := q.db.Exec(ctx, addEvidenceFile, arg.FileUrl, arg.ID)
	return err
}

const countChargebacks = `-- name: CountChargebacks :one
SELECT COUNT(*) FROM chargebacks
WHERE
    ($1::varchar IS NULL OR agent_id = $1) AND
    ($2::varchar IS NULL OR customer_id = $2) AND
    ($3::uuid IS NULL OR group_id = $3) AND
    ($4::varchar IS NULL OR status = $4) AND
    ($5::date IS NULL OR dispute_date >= $5) AND
    ($6::date IS NULL OR dispute_date <= $6)
`

type CountChargebacksParams struct {
	AgentID         pgtype.Text `json:"agent_id"`
	CustomerID      pgtype.Text `json:"customer_id"`
	GroupID         pgtype.UUID `json:"group_id"`
	Status          pgtype.Text `json:"status"`
	DisputeDateFrom pgtype.Date `json:"dispute_date_from"`
	DisputeDateTo   pgtype.Date `json:"dispute_date_to"`
}

func (q *Queries) CountChargebacks(ctx context.Context, arg CountChargebacksParams) (int64, error) {
	row := q.db.QueryRow(ctx, countChargebacks,
		arg.AgentID,
		arg.CustomerID,
		arg.GroupID,
		arg.Status,
		arg.DisputeDateFrom,
		arg.DisputeDateTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChargeback = `-- name: CreateChargeback :one
INSERT INTO chargebacks (
    id, group_id, agent_id, customer_id,
    case_number, dispute_date, chargeback_date,
    chargeback_amount, currency, reason_code, reason_description,
    status, respond_by_date,
    evidence_files, response_notes, internal_notes,
    raw_data
) VALUES (
    $1, $2, $3, $4,
    $5, $6, $7,
    $8, $9, $10, $11,
    $12, $13,
    $14, $15, $16,
    $17
) RETURNING id, group_id, agent_id, customer_id, case_number, dispute_date, chargeback_date, chargeback_amount, currency, reason_code, reason_description, status, respond_by_date, response_submitted_at, resolved_at, evidence_files, response_notes, internal_notes, raw_data, deleted_at, created_at, updated_at
`

type CreateChargebackParams struct {
	ID                uuid.UUID       `json:"id"`
	GroupID           pgtype.UUID     `json:"group_id"`
	AgentID           string          `json:"agent_id"`
	CustomerID        pgtype.Text     `json:"customer_id"`
	CaseNumber        string          `json:"case_number"`
	DisputeDate       time.Time       `json:"dispute_date"`
	ChargebackDate    time.Time       `json:"chargeback_date"`
	ChargebackAmount  string          `json:"chargeback_amount"`
	Currency          string          `json:"currency"`
	ReasonCode        string          `json:"reason_code"`
	ReasonDescription pgtype.Text     `json:"reason_description"`
	Status            string          `json:"status"`
	RespondByDate     pgtype.Date     `json:"respond_by_date"`
	EvidenceFiles     []string        `json:"evidence_files"`
	ResponseNotes     pgtype.Text     `json:"response_notes"`
	InternalNotes     pgtype.Text     `json:"internal_notes"`
	RawData           json.RawMessage `json:"raw_data"`
}

func (q *Queries) CreateChargeback(ctx context.Context, arg CreateChargebackParams) (Chargeback, error) {
	row := q.db.QueryRow(ctx, createChargeback,
		arg.ID,
		arg.GroupID,
		arg.AgentID,
		arg.CustomerID,
		arg.CaseNumber,
		arg.DisputeDate,
		arg.ChargebackDate,
		arg.ChargebackAmount,
		arg.Currency,
		arg.ReasonCode,
		arg.ReasonDescription,
		arg.Status,
		arg.RespondByDate,
		arg.EvidenceFiles,
		arg.ResponseNotes,
		arg.InternalNotes,
		arg.RawData,
	)
	var i Chargeback
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.AgentID,
		&i.CustomerID,
		&i.CaseNumber,
		&i.DisputeDate,
		&i.ChargebackDate,
		&i.ChargebackAmount,
		&i.Currency,
		&i.ReasonCode,
		&i.ReasonDescription,
		&i.Status,
		&i.RespondByDate,
		&i.ResponseSubmittedAt,
		&i.ResolvedAt,
		&i.EvidenceFiles,
		&i.ResponseNotes,
		&i.InternalNotes,
		&i.RawData,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChargebackByCaseNumber = `-- name: GetChargebackByCaseNumber :one
SELECT id, group_id, agent_id, customer_id, case_number, dispute_date, chargeback_date, chargeback_amount, currency, reason_code, reason_description, status, respond_by_date, response_submitted_at, resolved_at, evidence_files, response_notes, internal_notes, raw_data, deleted_at, created_at, updated_at FROM chargebacks
WHERE agent_id = $1 AND case_number = $2
`

type GetChargebackByCaseNumberParams struct {
	AgentID    string `json:"agent_id"`
	CaseNumber string `json:"case_number"`
}

func (q *Queries) GetChargebackByCaseNumber(ctx context.Context, arg GetChargebackByCaseNumberParams) (Chargeback, error) {
	row := q.db.QueryRow(ctx, getChargebackByCaseNumber, arg.AgentID, arg.CaseNumber)
	var i Chargeback
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.AgentID,
		&i.CustomerID,
		&i.CaseNumber,
		&i.DisputeDate,
		&i.ChargebackDate,
		&i.ChargebackAmount,
		&i.Currency,
		&i.ReasonCode,
		&i.ReasonDescription,
		&i.Status,
		&i.RespondByDate,
		&i.ResponseSubmittedAt,
		&i.ResolvedAt,
		&i.EvidenceFiles,
		&i.ResponseNotes,
		&i.InternalNotes,
		&i.RawData,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChargebackByGroupID = `-- name: GetChargebackByGroupID :one
SELECT id, group_id, agent_id, customer_id, case_number, dispute_date, chargeback_date, chargeback_amount, currency, reason_code, reason_description, status, respond_by_date, response_submitted_at, resolved_at, evidence_files, response_notes, internal_notes, raw_data, deleted_at, created_at, updated_at FROM chargebacks
WHERE group_id = $1
`

func (q *Queries) GetChargebackByGroupID(ctx context.Context, groupID pgtype.UUID) (Chargeback, error) {
	row := q.db.QueryRow(ctx, getChargebackByGroupID, groupID)
	var i Chargeback
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.AgentID,
		&i.CustomerID,
		&i.CaseNumber,
		&i.DisputeDate,
		&i.ChargebackDate,
		&i.ChargebackAmount,
		&i.Currency,
		&i.ReasonCode,
		&i.ReasonDescription,
		&i.Status,
		&i.RespondByDate,
		&i.ResponseSubmittedAt,
		&i.ResolvedAt,
		&i.EvidenceFiles,
		&i.ResponseNotes,
		&i.InternalNotes,
		&i.RawData,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChargebackByID = `-- name: GetChargebackByID :one
SELECT id, group_id, agent_id, customer_id, case_number, dispute_date, chargeback_date, chargeback_amount, currency, reason_code, reason_description, status, respond_by_date, response_submitted_at, resolved_at, evidence_files, response_notes, internal_notes, raw_data, deleted_at, created_at, updated_at FROM chargebacks
WHERE id = $1
`

func (q *Queries) GetChargebackByID(ctx context.Context, id uuid.UUID) (Chargeback, error) {
	row := q.db.QueryRow(ctx, getChargebackByID, id)
	var i Chargeback
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.AgentID,
		&i.CustomerID,
		&i.CaseNumber,
		&i.DisputeDate,
		&i.ChargebackDate,
		&i.ChargebackAmount,
		&i.Currency,
		&i.ReasonCode,
		&i.ReasonDescription,
		&i.Status,
		&i.RespondByDate,
		&i.ResponseSubmittedAt,
		&i.ResolvedAt,
		&i.EvidenceFiles,
		&i.ResponseNotes,
		&i.InternalNotes,
		&i.RawData,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listChargebacks = `-- name: ListChargebacks :many
SELECT id, group_id, agent_id, customer_id, case_number, dispute_date, chargeback_date, chargeback_amount, currency, reason_code, reason_description, status, respond_by_date, response_submitted_at, resolved_at, evidence_files, response_notes, internal_notes, raw_data, deleted_at, created_at, updated_at FROM chargebacks
WHERE
    ($1::varchar IS NULL OR agent_id = $1) AND
    ($2::varchar IS NULL OR customer_id = $2) AND
    ($3::uuid IS NULL OR group_id = $3) AND
    ($4::varchar IS NULL OR status = $4) AND
    ($5::date IS NULL OR dispute_date >= $5) AND
    ($6::date IS NULL OR dispute_date <= $6)
ORDER BY dispute_date DESC
LIMIT $8 OFFSET $7
`

type ListChargebacksParams struct {
	AgentID         pgtype.Text `json:"agent_id"`
	CustomerID      pgtype.Text `json:"customer_id"`
	GroupID         pgtype.UUID `json:"group_id"`
	Status          pgtype.Text `json:"status"`
	DisputeDateFrom pgtype.Date `json:"dispute_date_from"`
	DisputeDateTo   pgtype.Date `json:"dispute_date_to"`
	OffsetVal       int32       `json:"offset_val"`
	LimitVal        int32       `json:"limit_val"`
}

func (q *Queries) ListChargebacks(ctx context.Context, arg ListChargebacksParams) ([]Chargeback, error) {
	rows, err := q.db.Query(ctx, listChargebacks,
		arg.AgentID,
		arg.CustomerID,
		arg.GroupID,
		arg.Status,
		arg.DisputeDateFrom,
		arg.DisputeDateTo,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Chargeback{}
	for rows.Next() {
		var i Chargeback
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.AgentID,
			&i.CustomerID,
			&i.CaseNumber,
			&i.DisputeDate,
			&i.ChargebackDate,
			&i.ChargebackAmount,
			&i.Currency,
			&i.ReasonCode,
			&i.ReasonDescription,
			&i.Status,
			&i.RespondByDate,
			&i.ResponseSubmittedAt,
			&i.ResolvedAt,
			&i.EvidenceFiles,
			&i.ResponseNotes,
			&i.InternalNotes,
			&i.RawData,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markChargebackResolved = `-- name: MarkChargebackResolved :exec
UPDATE chargebacks
SET
    status = $1,
    resolved_at = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $3
`

type MarkChargebackResolvedParams struct {
	Status     string             `json:"status"`
	ResolvedAt pgtype.Timestamptz `json:"resolved_at"`
	ID         uuid.UUID          `json:"id"`
}

func (q *Queries) MarkChargebackResolved(ctx context.Context, arg MarkChargebackResolvedParams) error {
	_, err := q.db.Exec(ctx, markChargebackResolved, arg.Status, arg.ResolvedAt, arg.ID)
	return err
}

const updateChargeback = `-- name: UpdateChargeback :one
UPDATE chargebacks
SET
    status = $1,
    response_submitted_at = $2,
    resolved_at = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $4
RETURNING id, group_id, agent_id, customer_id, case_number, dispute_date, chargeback_date, chargeback_amount, currency, reason_code, reason_description, status, respond_by_date, response_submitted_at, resolved_at, evidence_files, response_notes, internal_notes, raw_data, deleted_at, created_at, updated_at
`

type UpdateChargebackParams struct {
	Status              string             `json:"status"`
	ResponseSubmittedAt pgtype.Timestamptz `json:"response_submitted_at"`
	ResolvedAt          pgtype.Timestamptz `json:"resolved_at"`
	ID                  uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateChargeback(ctx context.Context, arg UpdateChargebackParams) (Chargeback, error) {
	row := q.db.QueryRow(ctx, updateChargeback,
		arg.Status,
		arg.ResponseSubmittedAt,
		arg.ResolvedAt,
		arg.ID,
	)
	var i Chargeback
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.AgentID,
		&i.CustomerID,
		&i.CaseNumber,
		&i.DisputeDate,
		&i.ChargebackDate,
		&i.ChargebackAmount,
		&i.Currency,
		&i.ReasonCode,
		&i.ReasonDescription,
		&i.Status,
		&i.RespondByDate,
		&i.ResponseSubmittedAt,
		&i.ResolvedAt,
		&i.EvidenceFiles,
		&i.ResponseNotes,
		&i.InternalNotes,
		&i.RawData,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateChargebackNotes = `-- name: UpdateChargebackNotes :exec
UPDATE chargebacks
SET internal_notes = $1, updated_at = CURRENT_TIMESTAMP
WHERE id = $2
`

type UpdateChargebackNotesParams struct {
	InternalNotes pgtype.Text `json:"internal_notes"`
	ID            uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateChargebackNotes(ctx context.Context, arg UpdateChargebackNotesParams) error {
	_, err := q.db.Exec(ctx, updateChargebackNotes, arg.InternalNotes, arg.ID)
	return err
}

const updateChargebackResponse = `-- name: UpdateChargebackResponse :exec
UPDATE chargebacks
SET
    response_notes = $1,
    response_submitted_at = CURRENT_TIMESTAMP,
    status = 'responded',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $2
`

type UpdateChargebackResponseParams struct {
	ResponseNotes pgtype.Text `json:"response_notes"`
	ID            uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateChargebackResponse(ctx context.Context, arg UpdateChargebackResponseParams) error {
	_, err := q.db.Exec(ctx, updateChargebackResponse, arg.ResponseNotes, arg.ID)
	return err
}

const updateChargebackStatus = `-- name: UpdateChargebackStatus :one
UPDATE chargebacks
SET
    status = $1,
    dispute_date = $2,
    chargeback_date = $3,
    chargeback_amount = $4,
    reason_code = $5,
    reason_description = $6,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $7
RETURNING id, group_id, agent_id, customer_id, case_number, dispute_date, chargeback_date, chargeback_amount, currency, reason_code, reason_description, status, respond_by_date, response_submitted_at, resolved_at, evidence_files, response_notes, internal_notes, raw_data, deleted_at, created_at, updated_at
`

type UpdateChargebackStatusParams struct {
	Status            string      `json:"status"`
	DisputeDate       time.Time   `json:"dispute_date"`
	ChargebackDate    time.Time   `json:"chargeback_date"`
	ChargebackAmount  string      `json:"chargeback_amount"`
	ReasonCode        string      `json:"reason_code"`
	ReasonDescription pgtype.Text `json:"reason_description"`
	ID                uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateChargebackStatus(ctx context.Context, arg UpdateChargebackStatusParams) (Chargeback, error) {
	row := q.db.QueryRow(ctx, updateChargebackStatus,
		arg.Status,
		arg.DisputeDate,
		arg.ChargebackDate,
		arg.ChargebackAmount,
		arg.ReasonCode,
		arg.ReasonDescription,
		arg.ID,
	)
	var i Chargeback
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.AgentID,
		&i.CustomerID,
		&i.CaseNumber,
		&i.DisputeDate,
		&i.ChargebackDate,
		&i.ChargebackAmount,
		&i.Currency,
		&i.ReasonCode,
		&i.ReasonDescription,
		&i.Status,
		&i.RespondByDate,
		&i.ResponseSubmittedAt,
		&i.ResolvedAt,
		&i.EvidenceFiles,
		&i.ResponseNotes,
		&i.InternalNotes,
		&i.RawData,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
