// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: services.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const activateService = `-- name: ActivateService :exec
UPDATE services
SET is_active = true, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) ActivateService(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, activateService, id)
	return err
}

const createService = `-- name: CreateService :one
INSERT INTO services (
    id, service_id, service_name, public_key, public_key_fingerprint,
    environment, requests_per_second, burst_limit, is_active, created_by
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9, $10
) RETURNING id, service_id, service_name, public_key, public_key_fingerprint, environment, requests_per_second, burst_limit, is_active, created_by, created_at, updated_at
`

type CreateServiceParams struct {
	ID                   uuid.UUID   `json:"id"`
	ServiceID            string      `json:"service_id"`
	ServiceName          string      `json:"service_name"`
	PublicKey            string      `json:"public_key"`
	PublicKeyFingerprint string      `json:"public_key_fingerprint"`
	Environment          string      `json:"environment"`
	RequestsPerSecond    pgtype.Int4 `json:"requests_per_second"`
	BurstLimit           pgtype.Int4 `json:"burst_limit"`
	IsActive             pgtype.Bool `json:"is_active"`
	CreatedBy            pgtype.UUID `json:"created_by"`
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) (Service, error) {
	row := q.db.QueryRow(ctx, createService,
		arg.ID,
		arg.ServiceID,
		arg.ServiceName,
		arg.PublicKey,
		arg.PublicKeyFingerprint,
		arg.Environment,
		arg.RequestsPerSecond,
		arg.BurstLimit,
		arg.IsActive,
		arg.CreatedBy,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.ServiceName,
		&i.PublicKey,
		&i.PublicKeyFingerprint,
		&i.Environment,
		&i.RequestsPerSecond,
		&i.BurstLimit,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateService = `-- name: DeactivateService :exec
UPDATE services
SET is_active = false, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) DeactivateService(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateService, id)
	return err
}

const getServiceByID = `-- name: GetServiceByID :one
SELECT id, service_id, service_name, public_key, public_key_fingerprint, environment, requests_per_second, burst_limit, is_active, created_by, created_at, updated_at FROM services
WHERE id = $1
`

func (q *Queries) GetServiceByID(ctx context.Context, id uuid.UUID) (Service, error) {
	row := q.db.QueryRow(ctx, getServiceByID, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.ServiceName,
		&i.PublicKey,
		&i.PublicKeyFingerprint,
		&i.Environment,
		&i.RequestsPerSecond,
		&i.BurstLimit,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getServiceByServiceID = `-- name: GetServiceByServiceID :one
SELECT id, service_id, service_name, public_key, public_key_fingerprint, environment, requests_per_second, burst_limit, is_active, created_by, created_at, updated_at FROM services
WHERE service_id = $1 AND is_active = true
`

func (q *Queries) GetServiceByServiceID(ctx context.Context, serviceID string) (Service, error) {
	row := q.db.QueryRow(ctx, getServiceByServiceID, serviceID)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.ServiceName,
		&i.PublicKey,
		&i.PublicKeyFingerprint,
		&i.Environment,
		&i.RequestsPerSecond,
		&i.BurstLimit,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listServices = `-- name: ListServices :many
SELECT id, service_id, service_name, public_key, public_key_fingerprint, environment, requests_per_second, burst_limit, is_active, created_by, created_at, updated_at FROM services
WHERE
    ($1::varchar IS NULL OR environment = $1) AND
    ($2::boolean IS NULL OR is_active = $2)
ORDER BY created_at DESC
LIMIT $4 OFFSET $3
`

type ListServicesParams struct {
	Environment pgtype.Text `json:"environment"`
	IsActive    pgtype.Bool `json:"is_active"`
	OffsetVal   int32       `json:"offset_val"`
	LimitVal    int32       `json:"limit_val"`
}

func (q *Queries) ListServices(ctx context.Context, arg ListServicesParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, listServices,
		arg.Environment,
		arg.IsActive,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Service{}
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.ServiceName,
			&i.PublicKey,
			&i.PublicKeyFingerprint,
			&i.Environment,
			&i.RequestsPerSecond,
			&i.BurstLimit,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rotateServiceKey = `-- name: RotateServiceKey :one
UPDATE services
SET
    public_key = $1,
    public_key_fingerprint = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $3
RETURNING id, service_id, service_name, public_key, public_key_fingerprint, environment, requests_per_second, burst_limit, is_active, created_by, created_at, updated_at
`

type RotateServiceKeyParams struct {
	PublicKey            string    `json:"public_key"`
	PublicKeyFingerprint string    `json:"public_key_fingerprint"`
	ID                   uuid.UUID `json:"id"`
}

func (q *Queries) RotateServiceKey(ctx context.Context, arg RotateServiceKeyParams) (Service, error) {
	row := q.db.QueryRow(ctx, rotateServiceKey, arg.PublicKey, arg.PublicKeyFingerprint, arg.ID)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.ServiceName,
		&i.PublicKey,
		&i.PublicKeyFingerprint,
		&i.Environment,
		&i.RequestsPerSecond,
		&i.BurstLimit,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateService = `-- name: UpdateService :one
UPDATE services
SET
    service_name = $1,
    public_key = $2,
    public_key_fingerprint = $3,
    requests_per_second = $4,
    burst_limit = $5,
    is_active = $6,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $7
RETURNING id, service_id, service_name, public_key, public_key_fingerprint, environment, requests_per_second, burst_limit, is_active, created_by, created_at, updated_at
`

type UpdateServiceParams struct {
	ServiceName          string      `json:"service_name"`
	PublicKey            string      `json:"public_key"`
	PublicKeyFingerprint string      `json:"public_key_fingerprint"`
	RequestsPerSecond    pgtype.Int4 `json:"requests_per_second"`
	BurstLimit           pgtype.Int4 `json:"burst_limit"`
	IsActive             pgtype.Bool `json:"is_active"`
	ID                   uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateService(ctx context.Context, arg UpdateServiceParams) (Service, error) {
	row := q.db.QueryRow(ctx, updateService,
		arg.ServiceName,
		arg.PublicKey,
		arg.PublicKeyFingerprint,
		arg.RequestsPerSecond,
		arg.BurstLimit,
		arg.IsActive,
		arg.ID,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.ServiceName,
		&i.PublicKey,
		&i.PublicKeyFingerprint,
		&i.Environment,
		&i.RequestsPerSecond,
		&i.BurstLimit,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
