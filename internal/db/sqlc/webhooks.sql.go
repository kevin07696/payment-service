// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: webhooks.sql

package sqlc

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createWebhookDelivery = `-- name: CreateWebhookDelivery :one
INSERT INTO webhook_deliveries (
    subscription_id,
    event_type,
    payload,
    status,
    http_status_code,
    error_message,
    attempts,
    next_retry_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
) RETURNING id, subscription_id, event_type, payload, status, http_status_code, error_message, attempts, next_retry_at, delivered_at, created_at
`

type CreateWebhookDeliveryParams struct {
	SubscriptionID uuid.UUID          `json:"subscription_id"`
	EventType      string             `json:"event_type"`
	Payload        json.RawMessage    `json:"payload"`
	Status         string             `json:"status"`
	HttpStatusCode pgtype.Int4        `json:"http_status_code"`
	ErrorMessage   pgtype.Text        `json:"error_message"`
	Attempts       int32              `json:"attempts"`
	NextRetryAt    pgtype.Timestamptz `json:"next_retry_at"`
}

func (q *Queries) CreateWebhookDelivery(ctx context.Context, arg CreateWebhookDeliveryParams) (WebhookDelivery, error) {
	row := q.db.QueryRow(ctx, createWebhookDelivery,
		arg.SubscriptionID,
		arg.EventType,
		arg.Payload,
		arg.Status,
		arg.HttpStatusCode,
		arg.ErrorMessage,
		arg.Attempts,
		arg.NextRetryAt,
	)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.HttpStatusCode,
		&i.ErrorMessage,
		&i.Attempts,
		&i.NextRetryAt,
		&i.DeliveredAt,
		&i.CreatedAt,
	)
	return i, err
}

const createWebhookSubscription = `-- name: CreateWebhookSubscription :one
INSERT INTO webhook_subscriptions (
    agent_id,
    event_type,
    webhook_url,
    secret,
    is_active
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
) RETURNING id, agent_id, event_type, webhook_url, secret, is_active, created_at, updated_at
`

type CreateWebhookSubscriptionParams struct {
	AgentID    string `json:"agent_id"`
	EventType  string `json:"event_type"`
	WebhookUrl string `json:"webhook_url"`
	Secret     string `json:"secret"`
	IsActive   bool   `json:"is_active"`
}

func (q *Queries) CreateWebhookSubscription(ctx context.Context, arg CreateWebhookSubscriptionParams) (WebhookSubscription, error) {
	row := q.db.QueryRow(ctx, createWebhookSubscription,
		arg.AgentID,
		arg.EventType,
		arg.WebhookUrl,
		arg.Secret,
		arg.IsActive,
	)
	var i WebhookSubscription
	err := row.Scan(
		&i.ID,
		&i.AgentID,
		&i.EventType,
		&i.WebhookUrl,
		&i.Secret,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteWebhookSubscription = `-- name: DeleteWebhookSubscription :exec
DELETE FROM webhook_subscriptions
WHERE id = $1 AND agent_id = $2
`

type DeleteWebhookSubscriptionParams struct {
	ID      uuid.UUID `json:"id"`
	AgentID string    `json:"agent_id"`
}

func (q *Queries) DeleteWebhookSubscription(ctx context.Context, arg DeleteWebhookSubscriptionParams) error {
	_, err := q.db.Exec(ctx, deleteWebhookSubscription, arg.ID, arg.AgentID)
	return err
}

const getWebhookDeliveryHistory = `-- name: GetWebhookDeliveryHistory :many
SELECT id, subscription_id, event_type, payload, status, http_status_code, error_message, attempts, next_retry_at, delivered_at, created_at FROM webhook_deliveries
WHERE subscription_id = $1
ORDER BY created_at DESC
LIMIT $3
OFFSET $2
`

type GetWebhookDeliveryHistoryParams struct {
	SubscriptionID uuid.UUID `json:"subscription_id"`
	OffsetVal      int32     `json:"offset_val"`
	LimitVal       int32     `json:"limit_val"`
}

func (q *Queries) GetWebhookDeliveryHistory(ctx context.Context, arg GetWebhookDeliveryHistoryParams) ([]WebhookDelivery, error) {
	rows, err := q.db.Query(ctx, getWebhookDeliveryHistory, arg.SubscriptionID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookDelivery{}
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.EventType,
			&i.Payload,
			&i.Status,
			&i.HttpStatusCode,
			&i.ErrorMessage,
			&i.Attempts,
			&i.NextRetryAt,
			&i.DeliveredAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhookSubscription = `-- name: GetWebhookSubscription :one
SELECT id, agent_id, event_type, webhook_url, secret, is_active, created_at, updated_at FROM webhook_subscriptions
WHERE id = $1
`

func (q *Queries) GetWebhookSubscription(ctx context.Context, id uuid.UUID) (WebhookSubscription, error) {
	row := q.db.QueryRow(ctx, getWebhookSubscription, id)
	var i WebhookSubscription
	err := row.Scan(
		&i.ID,
		&i.AgentID,
		&i.EventType,
		&i.WebhookUrl,
		&i.Secret,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveWebhooksByEvent = `-- name: ListActiveWebhooksByEvent :many
SELECT id, agent_id, event_type, webhook_url, secret, is_active, created_at, updated_at FROM webhook_subscriptions
WHERE agent_id = $1
  AND event_type = $2
  AND is_active = true
`

type ListActiveWebhooksByEventParams struct {
	AgentID   string `json:"agent_id"`
	EventType string `json:"event_type"`
}

func (q *Queries) ListActiveWebhooksByEvent(ctx context.Context, arg ListActiveWebhooksByEventParams) ([]WebhookSubscription, error) {
	rows, err := q.db.Query(ctx, listActiveWebhooksByEvent, arg.AgentID, arg.EventType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookSubscription{}
	for rows.Next() {
		var i WebhookSubscription
		if err := rows.Scan(
			&i.ID,
			&i.AgentID,
			&i.EventType,
			&i.WebhookUrl,
			&i.Secret,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingWebhookDeliveries = `-- name: ListPendingWebhookDeliveries :many
SELECT id, subscription_id, event_type, payload, status, http_status_code, error_message, attempts, next_retry_at, delivered_at, created_at FROM webhook_deliveries
WHERE status = 'pending'
  AND next_retry_at <= CURRENT_TIMESTAMP
ORDER BY next_retry_at ASC
LIMIT $1
`

func (q *Queries) ListPendingWebhookDeliveries(ctx context.Context, limitVal int32) ([]WebhookDelivery, error) {
	rows, err := q.db.Query(ctx, listPendingWebhookDeliveries, limitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookDelivery{}
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.EventType,
			&i.Payload,
			&i.Status,
			&i.HttpStatusCode,
			&i.ErrorMessage,
			&i.Attempts,
			&i.NextRetryAt,
			&i.DeliveredAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookSubscriptions = `-- name: ListWebhookSubscriptions :many
SELECT id, agent_id, event_type, webhook_url, secret, is_active, created_at, updated_at FROM webhook_subscriptions
WHERE agent_id = $1
  AND ($2::boolean IS NULL OR is_active = $2)
ORDER BY created_at DESC
`

type ListWebhookSubscriptionsParams struct {
	AgentID  string      `json:"agent_id"`
	IsActive pgtype.Bool `json:"is_active"`
}

func (q *Queries) ListWebhookSubscriptions(ctx context.Context, arg ListWebhookSubscriptionsParams) ([]WebhookSubscription, error) {
	rows, err := q.db.Query(ctx, listWebhookSubscriptions, arg.AgentID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookSubscription{}
	for rows.Next() {
		var i WebhookSubscription
		if err := rows.Scan(
			&i.ID,
			&i.AgentID,
			&i.EventType,
			&i.WebhookUrl,
			&i.Secret,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWebhookDeliveryStatus = `-- name: UpdateWebhookDeliveryStatus :one
UPDATE webhook_deliveries
SET
    status = $1,
    http_status_code = $2,
    error_message = $3,
    attempts = $4,
    next_retry_at = $5,
    delivered_at = $6
WHERE id = $7
RETURNING id, subscription_id, event_type, payload, status, http_status_code, error_message, attempts, next_retry_at, delivered_at, created_at
`

type UpdateWebhookDeliveryStatusParams struct {
	Status         string             `json:"status"`
	HttpStatusCode pgtype.Int4        `json:"http_status_code"`
	ErrorMessage   pgtype.Text        `json:"error_message"`
	Attempts       int32              `json:"attempts"`
	NextRetryAt    pgtype.Timestamptz `json:"next_retry_at"`
	DeliveredAt    pgtype.Timestamptz `json:"delivered_at"`
	ID             uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateWebhookDeliveryStatus(ctx context.Context, arg UpdateWebhookDeliveryStatusParams) (WebhookDelivery, error) {
	row := q.db.QueryRow(ctx, updateWebhookDeliveryStatus,
		arg.Status,
		arg.HttpStatusCode,
		arg.ErrorMessage,
		arg.Attempts,
		arg.NextRetryAt,
		arg.DeliveredAt,
		arg.ID,
	)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.HttpStatusCode,
		&i.ErrorMessage,
		&i.Attempts,
		&i.NextRetryAt,
		&i.DeliveredAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateWebhookSubscription = `-- name: UpdateWebhookSubscription :one
UPDATE webhook_subscriptions
SET
    webhook_url = COALESCE($1, webhook_url),
    secret = COALESCE($2, secret),
    is_active = COALESCE($3, is_active),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $4
RETURNING id, agent_id, event_type, webhook_url, secret, is_active, created_at, updated_at
`

type UpdateWebhookSubscriptionParams struct {
	WebhookUrl pgtype.Text `json:"webhook_url"`
	Secret     pgtype.Text `json:"secret"`
	IsActive   pgtype.Bool `json:"is_active"`
	ID         uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateWebhookSubscription(ctx context.Context, arg UpdateWebhookSubscriptionParams) (WebhookSubscription, error) {
	row := q.db.QueryRow(ctx, updateWebhookSubscription,
		arg.WebhookUrl,
		arg.Secret,
		arg.IsActive,
		arg.ID,
	)
	var i WebhookSubscription
	err := row.Scan(
		&i.ID,
		&i.AgentID,
		&i.EventType,
		&i.WebhookUrl,
		&i.Secret,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
