// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rate_limits.sql

package sqlc

import (
	"context"
)

const cleanupOldRateLimitBuckets = `-- name: CleanupOldRateLimitBuckets :exec
DELETE FROM rate_limit_buckets
WHERE last_refill < NOW() - INTERVAL '1 hour'
`

// Remove old rate limit bucket entries
func (q *Queries) CleanupOldRateLimitBuckets(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupOldRateLimitBuckets)
	return err
}

const consumeRateLimitToken = `-- name: ConsumeRateLimitToken :one
INSERT INTO rate_limit_buckets (bucket_key, tokens, last_refill)
VALUES ($1, $2, NOW())
ON CONFLICT (bucket_key) DO UPDATE
SET tokens = GREATEST(rate_limit_buckets.tokens - 1, 0),
    last_refill = NOW()
RETURNING tokens
`

type ConsumeRateLimitTokenParams struct {
	BucketKey     string `json:"bucket_key"`
	InitialTokens int32  `json:"initial_tokens"`
}

// Atomically consume a token from the rate limit bucket
// Returns the number of tokens remaining after consumption
func (q *Queries) ConsumeRateLimitToken(ctx context.Context, arg ConsumeRateLimitTokenParams) (int32, error) {
	row := q.db.QueryRow(ctx, consumeRateLimitToken, arg.BucketKey, arg.InitialTokens)
	var tokens int32
	err := row.Scan(&tokens)
	return tokens, err
}

const getRateLimitBucket = `-- name: GetRateLimitBucket :one
SELECT bucket_key, tokens, last_refill, created_at FROM rate_limit_buckets
WHERE bucket_key = $1
`

// Get current state of a rate limit bucket
func (q *Queries) GetRateLimitBucket(ctx context.Context, bucketKey string) (RateLimitBucket, error) {
	row := q.db.QueryRow(ctx, getRateLimitBucket, bucketKey)
	var i RateLimitBucket
	err := row.Scan(
		&i.BucketKey,
		&i.Tokens,
		&i.LastRefill,
		&i.CreatedAt,
	)
	return i, err
}

const refillRateLimitBucket = `-- name: RefillRateLimitBucket :exec
UPDATE rate_limit_buckets
SET tokens = $1,
    last_refill = NOW()
WHERE bucket_key = $2
`

type RefillRateLimitBucketParams struct {
	Tokens    int32  `json:"tokens"`
	BucketKey string `json:"bucket_key"`
}

// Refill a rate limit bucket to maximum capacity
func (q *Queries) RefillRateLimitBucket(ctx context.Context, arg RefillRateLimitBucketParams) error {
	_, err := q.db.Exec(ctx, refillRateLimitBucket, arg.Tokens, arg.BucketKey)
	return err
}
