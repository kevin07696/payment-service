// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countTransactions = `-- name: CountTransactions :one
SELECT COUNT(*) FROM transactions
WHERE
    ($1::uuid IS NULL OR merchant_id = $1) AND
    ($2::varchar IS NULL OR customer_id = $2) AND
    ($3::uuid IS NULL OR group_id = $3) AND
    ($4::varchar IS NULL OR status = $4) AND
    ($5::varchar IS NULL OR type = $5) AND
    ($6::uuid IS NULL OR payment_method_id = $6)
`

type CountTransactionsParams struct {
	MerchantID      pgtype.UUID `json:"merchant_id"`
	CustomerID      pgtype.Text `json:"customer_id"`
	GroupID         pgtype.UUID `json:"group_id"`
	Status          pgtype.Text `json:"status"`
	Type            pgtype.Text `json:"type"`
	PaymentMethodID pgtype.UUID `json:"payment_method_id"`
}

func (q *Queries) CountTransactions(ctx context.Context, arg CountTransactionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTransactions,
		arg.MerchantID,
		arg.CustomerID,
		arg.GroupID,
		arg.Status,
		arg.Type,
		arg.PaymentMethodID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    id, merchant_id, customer_id,
    amount, currency, type, payment_method_type, payment_method_id, subscription_id,
    tran_nbr, auth_guid, auth_resp, auth_code, auth_card_type,
    metadata,
    group_id
) VALUES (
    $1, $2, $3,
    $4, $5, $6, $7, $8, $9,
    $10, $11, $12, $13, $14,
    $15,
    COALESCE($16, gen_random_uuid())
)
ON CONFLICT (id) DO NOTHING
RETURNING id, group_id, merchant_id, customer_id, amount, currency, type, payment_method_type, payment_method_id, subscription_id, tran_nbr, auth_guid, auth_resp, auth_code, auth_card_type, status, metadata, deleted_at, created_at, updated_at
`

type CreateTransactionParams struct {
	ID                uuid.UUID      `json:"id"`
	MerchantID        uuid.UUID      `json:"merchant_id"`
	CustomerID        pgtype.Text    `json:"customer_id"`
	Amount            pgtype.Numeric `json:"amount"`
	Currency          string         `json:"currency"`
	Type              string         `json:"type"`
	PaymentMethodType string         `json:"payment_method_type"`
	PaymentMethodID   pgtype.UUID    `json:"payment_method_id"`
	SubscriptionID    pgtype.UUID    `json:"subscription_id"`
	TranNbr           pgtype.Text    `json:"tran_nbr"`
	AuthGuid          pgtype.Text    `json:"auth_guid"`
	AuthResp          string         `json:"auth_resp"`
	AuthCode          pgtype.Text    `json:"auth_code"`
	AuthCardType      pgtype.Text    `json:"auth_card_type"`
	Metadata          []byte         `json:"metadata"`
	GroupID           interface{}    `json:"group_id"`
}

// Transactions are append-only/immutable event logs
// status is GENERATED column based on auth_resp, so we don't insert it
// Uses ON CONFLICT DO NOTHING for idempotency: EPX callback retries return existing record unchanged
// Modifications (VOID/REFUND) create NEW transaction records with same group_id
// auth_guid stores EPX BRIC for this transaction (each transaction can have its own BRIC)
// tran_nbr stores EPX TRAN_NBR (deterministic 10-digit numeric ID from UUID)
// group_id is a logical grouping UUID (NOT a foreign key) - auto-generates if not provided
func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.ID,
		arg.MerchantID,
		arg.CustomerID,
		arg.Amount,
		arg.Currency,
		arg.Type,
		arg.PaymentMethodType,
		arg.PaymentMethodID,
		arg.SubscriptionID,
		arg.TranNbr,
		arg.AuthGuid,
		arg.AuthResp,
		arg.AuthCode,
		arg.AuthCardType,
		arg.Metadata,
		arg.GroupID,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.MerchantID,
		&i.CustomerID,
		&i.Amount,
		&i.Currency,
		&i.Type,
		&i.PaymentMethodType,
		&i.PaymentMethodID,
		&i.SubscriptionID,
		&i.TranNbr,
		&i.AuthGuid,
		&i.AuthResp,
		&i.AuthCode,
		&i.AuthCardType,
		&i.Status,
		&i.Metadata,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, group_id, merchant_id, customer_id, amount, currency, type, payment_method_type, payment_method_id, subscription_id, tran_nbr, auth_guid, auth_resp, auth_code, auth_card_type, status, metadata, deleted_at, created_at, updated_at FROM transactions
WHERE id = $1
`

func (q *Queries) GetTransactionByID(ctx context.Context, id uuid.UUID) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.MerchantID,
		&i.CustomerID,
		&i.Amount,
		&i.Currency,
		&i.Type,
		&i.PaymentMethodType,
		&i.PaymentMethodID,
		&i.SubscriptionID,
		&i.TranNbr,
		&i.AuthGuid,
		&i.AuthResp,
		&i.AuthCode,
		&i.AuthCardType,
		&i.Status,
		&i.Metadata,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByTranNbr = `-- name: GetTransactionByTranNbr :one

SELECT id, group_id, merchant_id, customer_id, amount, currency, type, payment_method_type, payment_method_id, subscription_id, tran_nbr, auth_guid, auth_resp, auth_code, auth_card_type, status, metadata, deleted_at, created_at, updated_at FROM transactions
WHERE tran_nbr = $1
LIMIT 1
`

// UpdateTransaction removed: transactions are immutable/append-only
// To modify a transaction (VOID/REFUND), create a NEW transaction record with same group_id
func (q *Queries) GetTransactionByTranNbr(ctx context.Context, tranNbr pgtype.Text) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByTranNbr, tranNbr)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.MerchantID,
		&i.CustomerID,
		&i.Amount,
		&i.Currency,
		&i.Type,
		&i.PaymentMethodType,
		&i.PaymentMethodID,
		&i.SubscriptionID,
		&i.TranNbr,
		&i.AuthGuid,
		&i.AuthResp,
		&i.AuthCode,
		&i.AuthCardType,
		&i.Status,
		&i.Metadata,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionsByGroupID = `-- name: GetTransactionsByGroupID :many
SELECT id, group_id, merchant_id, customer_id, amount, currency, type, payment_method_type, payment_method_id, subscription_id, tran_nbr, auth_guid, auth_resp, auth_code, auth_card_type, status, metadata, deleted_at, created_at, updated_at FROM transactions
WHERE group_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetTransactionsByGroupID(ctx context.Context, groupID uuid.UUID) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByGroupID, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.MerchantID,
			&i.CustomerID,
			&i.Amount,
			&i.Currency,
			&i.Type,
			&i.PaymentMethodType,
			&i.PaymentMethodID,
			&i.SubscriptionID,
			&i.TranNbr,
			&i.AuthGuid,
			&i.AuthResp,
			&i.AuthCode,
			&i.AuthCardType,
			&i.Status,
			&i.Metadata,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT id, group_id, merchant_id, customer_id, amount, currency, type, payment_method_type, payment_method_id, subscription_id, tran_nbr, auth_guid, auth_resp, auth_code, auth_card_type, status, metadata, deleted_at, created_at, updated_at FROM transactions
WHERE
    ($1::uuid IS NULL OR merchant_id = $1) AND
    ($2::varchar IS NULL OR customer_id = $2) AND
    ($3::uuid IS NULL OR group_id = $3) AND
    ($4::varchar IS NULL OR status = $4) AND
    ($5::varchar IS NULL OR type = $5) AND
    ($6::uuid IS NULL OR payment_method_id = $6)
ORDER BY created_at DESC
LIMIT $8 OFFSET $7
`

type ListTransactionsParams struct {
	MerchantID      pgtype.UUID `json:"merchant_id"`
	CustomerID      pgtype.Text `json:"customer_id"`
	GroupID         pgtype.UUID `json:"group_id"`
	Status          pgtype.Text `json:"status"`
	Type            pgtype.Text `json:"type"`
	PaymentMethodID pgtype.UUID `json:"payment_method_id"`
	OffsetVal       int32       `json:"offset_val"`
	LimitVal        int32       `json:"limit_val"`
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactions,
		arg.MerchantID,
		arg.CustomerID,
		arg.GroupID,
		arg.Status,
		arg.Type,
		arg.PaymentMethodID,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.MerchantID,
			&i.CustomerID,
			&i.Amount,
			&i.Currency,
			&i.Type,
			&i.PaymentMethodType,
			&i.PaymentMethodID,
			&i.SubscriptionID,
			&i.TranNbr,
			&i.AuthGuid,
			&i.AuthResp,
			&i.AuthCode,
			&i.AuthCardType,
			&i.Status,
			&i.Metadata,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionFromEPXResponse = `-- name: UpdateTransactionFromEPXResponse :one
UPDATE transactions SET
    auth_guid = COALESCE($1, auth_guid),
    auth_resp = COALESCE($2, auth_resp),
    auth_code = COALESCE($3, auth_code),
    auth_card_type = COALESCE($4, auth_card_type),
    metadata = COALESCE($5, metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE tran_nbr = $6
RETURNING id, group_id, merchant_id, customer_id, amount, currency, type, payment_method_type, payment_method_id, subscription_id, tran_nbr, auth_guid, auth_resp, auth_code, auth_card_type, status, metadata, deleted_at, created_at, updated_at
`

type UpdateTransactionFromEPXResponseParams struct {
	AuthGuid     pgtype.Text `json:"auth_guid"`
	AuthResp     string      `json:"auth_resp"`
	AuthCode     pgtype.Text `json:"auth_code"`
	AuthCardType pgtype.Text `json:"auth_card_type"`
	Metadata     []byte      `json:"metadata"`
	TranNbr      pgtype.Text `json:"tran_nbr"`
}

// Updates transaction with EPX response data (for Browser Post callback)
// Only updates EPX response fields, leaves core transaction data unchanged
func (q *Queries) UpdateTransactionFromEPXResponse(ctx context.Context, arg UpdateTransactionFromEPXResponseParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransactionFromEPXResponse,
		arg.AuthGuid,
		arg.AuthResp,
		arg.AuthCode,
		arg.AuthCardType,
		arg.Metadata,
		arg.TranNbr,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.MerchantID,
		&i.CustomerID,
		&i.Amount,
		&i.Currency,
		&i.Type,
		&i.PaymentMethodType,
		&i.PaymentMethodID,
		&i.SubscriptionID,
		&i.TranNbr,
		&i.AuthGuid,
		&i.AuthResp,
		&i.AuthCode,
		&i.AuthCardType,
		&i.Status,
		&i.Metadata,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
