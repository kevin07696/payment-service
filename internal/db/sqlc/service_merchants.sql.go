// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: service_merchants.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkServiceHasScope = `-- name: CheckServiceHasScope :one
SELECT EXISTS(
    SELECT 1 FROM service_merchants
    WHERE service_id = $1
        AND merchant_id = $2
        AND $3::text = ANY(scopes)
        AND (expires_at IS NULL OR expires_at > NOW())
) as has_scope
`

type CheckServiceHasScopeParams struct {
	ServiceID  uuid.UUID `json:"service_id"`
	MerchantID uuid.UUID `json:"merchant_id"`
	Scope      string    `json:"scope"`
}

func (q *Queries) CheckServiceHasScope(ctx context.Context, arg CheckServiceHasScopeParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkServiceHasScope, arg.ServiceID, arg.MerchantID, arg.Scope)
	var has_scope bool
	err := row.Scan(&has_scope)
	return has_scope, err
}

const checkServiceMerchantAccessByID = `-- name: CheckServiceMerchantAccessByID :one
SELECT EXISTS(
    SELECT 1 FROM service_merchants sm
    JOIN services s ON sm.service_id = s.id
    JOIN merchants m ON sm.merchant_id = m.id
    WHERE s.service_id = $1
        AND m.id = $2
        AND s.is_active = true
        AND m.is_active = true
        AND (sm.expires_at IS NULL OR sm.expires_at > NOW())
) as has_access
`

type CheckServiceMerchantAccessByIDParams struct {
	ServiceID  string    `json:"service_id"`
	MerchantID uuid.UUID `json:"merchant_id"`
}

// Check if a service has access to a merchant by merchant UUID (for authentication)
func (q *Queries) CheckServiceMerchantAccessByID(ctx context.Context, arg CheckServiceMerchantAccessByIDParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkServiceMerchantAccessByID, arg.ServiceID, arg.MerchantID)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const checkServiceMerchantAccessBySlug = `-- name: CheckServiceMerchantAccessBySlug :one
SELECT EXISTS(
    SELECT 1 FROM service_merchants sm
    JOIN services s ON sm.service_id = s.id
    JOIN merchants m ON sm.merchant_id = m.id
    WHERE s.service_id = $1
        AND m.slug = $2
        AND s.is_active = true
        AND m.is_active = true
        AND (sm.expires_at IS NULL OR sm.expires_at > NOW())
) as has_access
`

type CheckServiceMerchantAccessBySlugParams struct {
	ServiceID    string `json:"service_id"`
	MerchantSlug string `json:"merchant_slug"`
}

// Check if a service has access to a merchant by merchant slug (for authentication)
func (q *Queries) CheckServiceMerchantAccessBySlug(ctx context.Context, arg CheckServiceMerchantAccessBySlugParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkServiceMerchantAccessBySlug, arg.ServiceID, arg.MerchantSlug)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const getServiceMerchantAccess = `-- name: GetServiceMerchantAccess :one
SELECT service_id, merchant_id, scopes, granted_by, granted_at, expires_at FROM service_merchants
WHERE service_id = $1 AND merchant_id = $2
`

type GetServiceMerchantAccessParams struct {
	ServiceID  uuid.UUID `json:"service_id"`
	MerchantID uuid.UUID `json:"merchant_id"`
}

func (q *Queries) GetServiceMerchantAccess(ctx context.Context, arg GetServiceMerchantAccessParams) (ServiceMerchant, error) {
	row := q.db.QueryRow(ctx, getServiceMerchantAccess, arg.ServiceID, arg.MerchantID)
	var i ServiceMerchant
	err := row.Scan(
		&i.ServiceID,
		&i.MerchantID,
		&i.Scopes,
		&i.GrantedBy,
		&i.GrantedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const grantServiceAccess = `-- name: GrantServiceAccess :one
INSERT INTO service_merchants (
    service_id, merchant_id, scopes, granted_by, expires_at
) VALUES (
    $1, $2, $3, $4, $5
)
ON CONFLICT (service_id, merchant_id) DO UPDATE
SET
    scopes = EXCLUDED.scopes,
    granted_by = EXCLUDED.granted_by,
    granted_at = CURRENT_TIMESTAMP,
    expires_at = EXCLUDED.expires_at
RETURNING service_id, merchant_id, scopes, granted_by, granted_at, expires_at
`

type GrantServiceAccessParams struct {
	ServiceID  uuid.UUID          `json:"service_id"`
	MerchantID uuid.UUID          `json:"merchant_id"`
	Scopes     []string           `json:"scopes"`
	GrantedBy  pgtype.UUID        `json:"granted_by"`
	ExpiresAt  pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) GrantServiceAccess(ctx context.Context, arg GrantServiceAccessParams) (ServiceMerchant, error) {
	row := q.db.QueryRow(ctx, grantServiceAccess,
		arg.ServiceID,
		arg.MerchantID,
		arg.Scopes,
		arg.GrantedBy,
		arg.ExpiresAt,
	)
	var i ServiceMerchant
	err := row.Scan(
		&i.ServiceID,
		&i.MerchantID,
		&i.Scopes,
		&i.GrantedBy,
		&i.GrantedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const listMerchantServices = `-- name: ListMerchantServices :many
SELECT sm.service_id, sm.merchant_id, sm.scopes, sm.granted_by, sm.granted_at, sm.expires_at, s.service_name, s.environment, s.is_active
FROM service_merchants sm
JOIN services s ON sm.service_id = s.id
WHERE sm.merchant_id = $1
ORDER BY sm.granted_at DESC
`

type ListMerchantServicesRow struct {
	ServiceID   uuid.UUID          `json:"service_id"`
	MerchantID  uuid.UUID          `json:"merchant_id"`
	Scopes      []string           `json:"scopes"`
	GrantedBy   pgtype.UUID        `json:"granted_by"`
	GrantedAt   pgtype.Timestamptz `json:"granted_at"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	ServiceName string             `json:"service_name"`
	Environment string             `json:"environment"`
	IsActive    pgtype.Bool        `json:"is_active"`
}

// Get all services that have access to a merchant
func (q *Queries) ListMerchantServices(ctx context.Context, merchantID uuid.UUID) ([]ListMerchantServicesRow, error) {
	rows, err := q.db.Query(ctx, listMerchantServices, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMerchantServicesRow{}
	for rows.Next() {
		var i ListMerchantServicesRow
		if err := rows.Scan(
			&i.ServiceID,
			&i.MerchantID,
			&i.Scopes,
			&i.GrantedBy,
			&i.GrantedAt,
			&i.ExpiresAt,
			&i.ServiceName,
			&i.Environment,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceMerchants = `-- name: ListServiceMerchants :many
SELECT sm.service_id, sm.merchant_id, sm.scopes, sm.granted_by, sm.granted_at, sm.expires_at, m.name as merchant_name, m.slug as merchant_slug
FROM service_merchants sm
JOIN merchants m ON sm.merchant_id = m.id
WHERE sm.service_id = $1
ORDER BY sm.granted_at DESC
`

type ListServiceMerchantsRow struct {
	ServiceID    uuid.UUID          `json:"service_id"`
	MerchantID   uuid.UUID          `json:"merchant_id"`
	Scopes       []string           `json:"scopes"`
	GrantedBy    pgtype.UUID        `json:"granted_by"`
	GrantedAt    pgtype.Timestamptz `json:"granted_at"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
	MerchantName string             `json:"merchant_name"`
	MerchantSlug string             `json:"merchant_slug"`
}

// Get all merchants a service has access to
func (q *Queries) ListServiceMerchants(ctx context.Context, serviceID uuid.UUID) ([]ListServiceMerchantsRow, error) {
	rows, err := q.db.Query(ctx, listServiceMerchants, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServiceMerchantsRow{}
	for rows.Next() {
		var i ListServiceMerchantsRow
		if err := rows.Scan(
			&i.ServiceID,
			&i.MerchantID,
			&i.Scopes,
			&i.GrantedBy,
			&i.GrantedAt,
			&i.ExpiresAt,
			&i.MerchantName,
			&i.MerchantSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeServiceAccess = `-- name: RevokeServiceAccess :exec
DELETE FROM service_merchants
WHERE service_id = $1 AND merchant_id = $2
`

type RevokeServiceAccessParams struct {
	ServiceID  uuid.UUID `json:"service_id"`
	MerchantID uuid.UUID `json:"merchant_id"`
}

func (q *Queries) RevokeServiceAccess(ctx context.Context, arg RevokeServiceAccessParams) error {
	_, err := q.db.Exec(ctx, revokeServiceAccess, arg.ServiceID, arg.MerchantID)
	return err
}

const updateServiceScopes = `-- name: UpdateServiceScopes :one
UPDATE service_merchants
SET
    scopes = $1,
    granted_at = CURRENT_TIMESTAMP
WHERE service_id = $2 AND merchant_id = $3
RETURNING service_id, merchant_id, scopes, granted_by, granted_at, expires_at
`

type UpdateServiceScopesParams struct {
	Scopes     []string  `json:"scopes"`
	ServiceID  uuid.UUID `json:"service_id"`
	MerchantID uuid.UUID `json:"merchant_id"`
}

func (q *Queries) UpdateServiceScopes(ctx context.Context, arg UpdateServiceScopesParams) (ServiceMerchant, error) {
	row := q.db.QueryRow(ctx, updateServiceScopes, arg.Scopes, arg.ServiceID, arg.MerchantID)
	var i ServiceMerchant
	err := row.Scan(
		&i.ServiceID,
		&i.MerchantID,
		&i.Scopes,
		&i.GrantedBy,
		&i.GrantedAt,
		&i.ExpiresAt,
	)
	return i, err
}
