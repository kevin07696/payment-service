// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jwt_blacklist.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const blacklistJWT = `-- name: BlacklistJWT :exec
INSERT INTO jwt_blacklist (
    jti, service_id, merchant_id, expires_at, blacklisted_by, reason
) VALUES (
    $1, $2, $3,
    $4, $5, $6
)
`

type BlacklistJWTParams struct {
	Jti           string           `json:"jti"`
	ServiceID     pgtype.Text      `json:"service_id"`
	MerchantID    pgtype.UUID      `json:"merchant_id"`
	ExpiresAt     pgtype.Timestamp `json:"expires_at"`
	BlacklistedBy pgtype.UUID      `json:"blacklisted_by"`
	Reason        pgtype.Text      `json:"reason"`
}

// Add a JWT token to the blacklist
func (q *Queries) BlacklistJWT(ctx context.Context, arg BlacklistJWTParams) error {
	_, err := q.db.Exec(ctx, blacklistJWT,
		arg.Jti,
		arg.ServiceID,
		arg.MerchantID,
		arg.ExpiresAt,
		arg.BlacklistedBy,
		arg.Reason,
	)
	return err
}

const cleanupExpiredBlacklist = `-- name: CleanupExpiredBlacklist :exec
DELETE FROM jwt_blacklist
WHERE expires_at < NOW()
`

// Remove expired entries from JWT blacklist
func (q *Queries) CleanupExpiredBlacklist(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredBlacklist)
	return err
}

const isJWTBlacklisted = `-- name: IsJWTBlacklisted :one
SELECT EXISTS(
    SELECT 1 FROM jwt_blacklist
    WHERE jti = $1
    AND expires_at > NOW()
) as is_blacklisted
`

// Check if a JWT token is blacklisted
func (q *Queries) IsJWTBlacklisted(ctx context.Context, jti string) (bool, error) {
	row := q.db.QueryRow(ctx, isJWTBlacklisted, jti)
	var is_blacklisted bool
	err := row.Scan(&is_blacklisted)
	return is_blacklisted, err
}
