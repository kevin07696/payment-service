// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payment_methods.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const activatePaymentMethod = `-- name: ActivatePaymentMethod :exec
UPDATE customer_payment_methods
SET is_active = true, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) ActivatePaymentMethod(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, activatePaymentMethod, id)
	return err
}

const createPaymentMethod = `-- name: CreatePaymentMethod :one
INSERT INTO customer_payment_methods (
    id, merchant_id, customer_id, payment_type,
    bric, last_four,
    card_brand, card_exp_month, card_exp_year,
    bank_name, account_type,
    is_default, is_active, is_verified
) VALUES (
    $1, $2, $3, $4,
    $5, $6,
    $7, $8, $9,
    $10, $11,
    $12, $13, $14
) RETURNING id, merchant_id, customer_id, bric, payment_type, last_four, card_brand, card_exp_month, card_exp_year, bank_name, account_type, is_default, is_active, is_verified, deleted_at, created_at, updated_at, last_used_at
`

type CreatePaymentMethodParams struct {
	ID           uuid.UUID   `json:"id"`
	MerchantID   uuid.UUID   `json:"merchant_id"`
	CustomerID   uuid.UUID   `json:"customer_id"`
	PaymentType  string      `json:"payment_type"`
	Bric         string      `json:"bric"`
	LastFour     string      `json:"last_four"`
	CardBrand    pgtype.Text `json:"card_brand"`
	CardExpMonth pgtype.Int4 `json:"card_exp_month"`
	CardExpYear  pgtype.Int4 `json:"card_exp_year"`
	BankName     pgtype.Text `json:"bank_name"`
	AccountType  pgtype.Text `json:"account_type"`
	IsDefault    pgtype.Bool `json:"is_default"`
	IsActive     pgtype.Bool `json:"is_active"`
	IsVerified   pgtype.Bool `json:"is_verified"`
}

func (q *Queries) CreatePaymentMethod(ctx context.Context, arg CreatePaymentMethodParams) (CustomerPaymentMethod, error) {
	row := q.db.QueryRow(ctx, createPaymentMethod,
		arg.ID,
		arg.MerchantID,
		arg.CustomerID,
		arg.PaymentType,
		arg.Bric,
		arg.LastFour,
		arg.CardBrand,
		arg.CardExpMonth,
		arg.CardExpYear,
		arg.BankName,
		arg.AccountType,
		arg.IsDefault,
		arg.IsActive,
		arg.IsVerified,
	)
	var i CustomerPaymentMethod
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CustomerID,
		&i.Bric,
		&i.PaymentType,
		&i.LastFour,
		&i.CardBrand,
		&i.CardExpMonth,
		&i.CardExpYear,
		&i.BankName,
		&i.AccountType,
		&i.IsDefault,
		&i.IsActive,
		&i.IsVerified,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const deactivatePaymentMethod = `-- name: DeactivatePaymentMethod :exec
UPDATE customer_payment_methods
SET is_active = false, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeactivatePaymentMethod(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivatePaymentMethod, id)
	return err
}

const deletePaymentMethod = `-- name: DeletePaymentMethod :exec
UPDATE customer_payment_methods
SET deleted_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeletePaymentMethod(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePaymentMethod, id)
	return err
}

const getDefaultPaymentMethod = `-- name: GetDefaultPaymentMethod :one
SELECT id, merchant_id, customer_id, bric, payment_type, last_four, card_brand, card_exp_month, card_exp_year, bank_name, account_type, is_default, is_active, is_verified, deleted_at, created_at, updated_at, last_used_at FROM customer_payment_methods
WHERE merchant_id = $1 AND customer_id = $2 AND is_default = true AND is_active = true AND deleted_at IS NULL
LIMIT 1
`

type GetDefaultPaymentMethodParams struct {
	MerchantID uuid.UUID `json:"merchant_id"`
	CustomerID uuid.UUID `json:"customer_id"`
}

func (q *Queries) GetDefaultPaymentMethod(ctx context.Context, arg GetDefaultPaymentMethodParams) (CustomerPaymentMethod, error) {
	row := q.db.QueryRow(ctx, getDefaultPaymentMethod, arg.MerchantID, arg.CustomerID)
	var i CustomerPaymentMethod
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CustomerID,
		&i.Bric,
		&i.PaymentType,
		&i.LastFour,
		&i.CardBrand,
		&i.CardExpMonth,
		&i.CardExpYear,
		&i.BankName,
		&i.AccountType,
		&i.IsDefault,
		&i.IsActive,
		&i.IsVerified,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const getPaymentMethodByID = `-- name: GetPaymentMethodByID :one
SELECT id, merchant_id, customer_id, bric, payment_type, last_four, card_brand, card_exp_month, card_exp_year, bank_name, account_type, is_default, is_active, is_verified, deleted_at, created_at, updated_at, last_used_at FROM customer_payment_methods
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPaymentMethodByID(ctx context.Context, id uuid.UUID) (CustomerPaymentMethod, error) {
	row := q.db.QueryRow(ctx, getPaymentMethodByID, id)
	var i CustomerPaymentMethod
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CustomerID,
		&i.Bric,
		&i.PaymentType,
		&i.LastFour,
		&i.CardBrand,
		&i.CardExpMonth,
		&i.CardExpYear,
		&i.BankName,
		&i.AccountType,
		&i.IsDefault,
		&i.IsActive,
		&i.IsVerified,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const listPaymentMethods = `-- name: ListPaymentMethods :many
SELECT id, merchant_id, customer_id, bric, payment_type, last_four, card_brand, card_exp_month, card_exp_year, bank_name, account_type, is_default, is_active, is_verified, deleted_at, created_at, updated_at, last_used_at FROM customer_payment_methods
WHERE
    deleted_at IS NULL AND
    ($1::uuid IS NULL OR merchant_id = $1) AND
    ($2::uuid IS NULL OR customer_id = $2) AND
    ($3::varchar IS NULL OR payment_type = $3) AND
    ($4::boolean IS NULL OR is_active = $4) AND
    ($5::boolean IS NULL OR is_default = $5)
ORDER BY is_default DESC, created_at DESC
`

type ListPaymentMethodsParams struct {
	MerchantID  pgtype.UUID `json:"merchant_id"`
	CustomerID  pgtype.UUID `json:"customer_id"`
	PaymentType pgtype.Text `json:"payment_type"`
	IsActive    pgtype.Bool `json:"is_active"`
	IsDefault   pgtype.Bool `json:"is_default"`
}

func (q *Queries) ListPaymentMethods(ctx context.Context, arg ListPaymentMethodsParams) ([]CustomerPaymentMethod, error) {
	rows, err := q.db.Query(ctx, listPaymentMethods,
		arg.MerchantID,
		arg.CustomerID,
		arg.PaymentType,
		arg.IsActive,
		arg.IsDefault,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CustomerPaymentMethod{}
	for rows.Next() {
		var i CustomerPaymentMethod
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.CustomerID,
			&i.Bric,
			&i.PaymentType,
			&i.LastFour,
			&i.CardBrand,
			&i.CardExpMonth,
			&i.CardExpYear,
			&i.BankName,
			&i.AccountType,
			&i.IsDefault,
			&i.IsActive,
			&i.IsVerified,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentMethodsByCustomer = `-- name: ListPaymentMethodsByCustomer :many
SELECT id, merchant_id, customer_id, bric, payment_type, last_four, card_brand, card_exp_month, card_exp_year, bank_name, account_type, is_default, is_active, is_verified, deleted_at, created_at, updated_at, last_used_at FROM customer_payment_methods
WHERE merchant_id = $1 AND customer_id = $2 AND deleted_at IS NULL
ORDER BY is_default DESC, created_at DESC
`

type ListPaymentMethodsByCustomerParams struct {
	MerchantID uuid.UUID `json:"merchant_id"`
	CustomerID uuid.UUID `json:"customer_id"`
}

func (q *Queries) ListPaymentMethodsByCustomer(ctx context.Context, arg ListPaymentMethodsByCustomerParams) ([]CustomerPaymentMethod, error) {
	rows, err := q.db.Query(ctx, listPaymentMethodsByCustomer, arg.MerchantID, arg.CustomerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CustomerPaymentMethod{}
	for rows.Next() {
		var i CustomerPaymentMethod
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.CustomerID,
			&i.Bric,
			&i.PaymentType,
			&i.LastFour,
			&i.CardBrand,
			&i.CardExpMonth,
			&i.CardExpYear,
			&i.BankName,
			&i.AccountType,
			&i.IsDefault,
			&i.IsActive,
			&i.IsVerified,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markPaymentMethodAsDefault = `-- name: MarkPaymentMethodAsDefault :exec
UPDATE customer_payment_methods
SET is_default = true, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

// Then set the specified one as default
func (q *Queries) MarkPaymentMethodAsDefault(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markPaymentMethodAsDefault, id)
	return err
}

const markPaymentMethodUsed = `-- name: MarkPaymentMethodUsed :exec
UPDATE customer_payment_methods
SET last_used_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) MarkPaymentMethodUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markPaymentMethodUsed, id)
	return err
}

const markPaymentMethodVerified = `-- name: MarkPaymentMethodVerified :exec
UPDATE customer_payment_methods
SET is_verified = true, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) MarkPaymentMethodVerified(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markPaymentMethodVerified, id)
	return err
}

const setPaymentMethodAsDefault = `-- name: SetPaymentMethodAsDefault :exec
UPDATE customer_payment_methods
SET is_default = false, updated_at = CURRENT_TIMESTAMP
WHERE merchant_id = $1 AND customer_id = $2 AND deleted_at IS NULL
`

type SetPaymentMethodAsDefaultParams struct {
	MerchantID uuid.UUID `json:"merchant_id"`
	CustomerID uuid.UUID `json:"customer_id"`
}

// First unset all defaults for this customer
func (q *Queries) SetPaymentMethodAsDefault(ctx context.Context, arg SetPaymentMethodAsDefaultParams) error {
	_, err := q.db.Exec(ctx, setPaymentMethodAsDefault, arg.MerchantID, arg.CustomerID)
	return err
}
