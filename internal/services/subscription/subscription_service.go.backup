package subscription

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/kevin07696/payment-service/internal/adapters/database"
	adapterports "github.com/kevin07696/payment-service/internal/adapters/ports"
	"github.com/kevin07696/payment-service/internal/db/sqlc"
	"github.com/kevin07696/payment-service/internal/domain"
	"github.com/kevin07696/payment-service/internal/services/ports"
	"github.com/shopspring/decimal"
	"go.uber.org/zap"
)

// subscriptionService implements the SubscriptionService port
type subscriptionService struct {
	db            *database.PostgreSQLAdapter
	serverPost    adapterports.ServerPostAdapter
	secretManager adapterports.SecretManagerAdapter
	logger        *zap.Logger
}

// NewSubscriptionService creates a new subscription service
func NewSubscriptionService(
	db *database.PostgreSQLAdapter,
	serverPost adapterports.ServerPostAdapter,
	secretManager adapterports.SecretManagerAdapter,
	logger *zap.Logger,
) ports.SubscriptionService {
	return &subscriptionService{
		db:            db,
		serverPost:    serverPost,
		secretManager: secretManager,
		logger:        logger,
	}
}

// CreateSubscription creates a new recurring billing subscription
func (s *subscriptionService) CreateSubscription(ctx context.Context, req *ports.CreateSubscriptionRequest) (*domain.Subscription, error) {
	s.logger.Info("Creating subscription",
		zap.String("agent_id", req.AgentID),
		zap.String("customer_id", req.CustomerID),
		zap.String("amount", req.Amount),
	)

	// Check idempotency
	if req.IdempotencyKey != nil {
		existing, err := s.getSubscriptionByIdempotencyKey(ctx, *req.IdempotencyKey)
		if err == nil {
			s.logger.Info("Idempotent request, returning existing subscription",
				zap.String("subscription_id", existing.ID),
			)
			return existing, nil
		}
	}

	// Parse and validate payment method ID
	pmID, err := uuid.Parse(req.PaymentMethodID)
	if err != nil {
		return nil, fmt.Errorf("invalid payment_method_id format: %w", err)
	}

	// Verify payment method exists and belongs to customer
	pm, err := s.db.Queries().GetPaymentMethodByID(ctx, pmID)
	if err != nil {
		return nil, fmt.Errorf("payment method not found: %w", err)
	}

	if pm.AgentID != req.AgentID || pm.CustomerID != req.CustomerID {
		return nil, fmt.Errorf("payment method does not belong to customer")
	}

	if !pm.IsActive.Valid || !pm.IsActive.Bool {
		return nil, fmt.Errorf("payment method is not active")
	}

	// Parse amount
	amount, err := decimal.NewFromString(req.Amount)
	if err != nil {
		return nil, fmt.Errorf("invalid amount format: %w", err)
	}

	if amount.LessThanOrEqual(decimal.Zero) {
		return nil, fmt.Errorf("amount must be greater than zero")
	}

	// Calculate next billing date
	nextBillingDate := calculateNextBillingDate(req.StartDate, req.IntervalValue, req.IntervalUnit)

	// Create subscription in database
	var subscription *domain.Subscription
	err = s.db.WithTx(ctx, func(q *sqlc.Queries) error {
		// Marshal metadata
		metadataJSON, err := json.Marshal(req.Metadata)
		if err != nil {
			s.logger.Warn("Failed to marshal metadata", zap.Error(err))
			metadataJSON = []byte("{}")
		}

		params := sqlc.CreateSubscriptionParams{
			ID:                    uuid.New(),
			AgentID:               req.AgentID,
			CustomerID:            req.CustomerID,
			Amount:                toNumeric(amount),
			Currency:              req.Currency,
			IntervalValue:         int32(req.IntervalValue),
			IntervalUnit:          string(req.IntervalUnit),
			Status:                string(domain.SubscriptionStatusActive),
			PaymentMethodID:       pmID,
			NextBillingDate:       pgtype.Timestamptz{Time: nextBillingDate, Valid: true},
			FailureRetryCount:     0,
			MaxRetries:            int32(req.MaxRetries),
			GatewaySubscriptionID: pgtype.Text{Valid: false}, // EPX doesn't use gateway subscription IDs
			Metadata:              metadataJSON,
		}

		dbSub, err := q.CreateSubscription(ctx, params)
		if err != nil {
			return fmt.Errorf("failed to create subscription: %w", err)
		}

		subscription = sqlcSubscriptionToDomain(&dbSub)
		return nil
	})

	if err != nil {
		return nil, err
	}

	s.logger.Info("Subscription created",
		zap.String("subscription_id", subscription.ID),
		zap.Time("next_billing_date", subscription.NextBillingDate),
	)

	return subscription, nil
}

// UpdateSubscription updates subscription properties
func (s *subscriptionService) UpdateSubscription(ctx context.Context, req *ports.UpdateSubscriptionRequest) (*domain.Subscription, error) {
	s.logger.Info("Updating subscription",
		zap.String("subscription_id", req.SubscriptionID),
	)

	// Check idempotency
	if req.IdempotencyKey != nil {
		existing, err := s.getSubscriptionByIdempotencyKey(ctx, *req.IdempotencyKey)
		if err == nil {
			return existing, nil
		}
	}

	// Parse subscription ID
	subID, err := uuid.Parse(req.SubscriptionID)
	if err != nil {
		return nil, fmt.Errorf("invalid subscription_id format: %w", err)
	}

	// Get existing subscription
	existing, err := s.db.Queries().GetSubscriptionByID(ctx, subID)
	if err != nil {
		return nil, fmt.Errorf("subscription not found: %w", err)
	}

	// Ensure subscription is active or past_due
	if existing.Status != string(domain.SubscriptionStatusActive) &&
		existing.Status != string(domain.SubscriptionStatusPastDue) {
		return nil, fmt.Errorf("cannot update subscription in %s status", existing.Status)
	}

	var subscription *domain.Subscription
	err = s.db.WithTx(ctx, func(q *sqlc.Queries) error {
		// Build update params
		params := sqlc.UpdateSubscriptionParams{
			ID: subID,
		}

		// Update amount if provided
		if req.Amount != nil {
			amount, err := decimal.NewFromString(*req.Amount)
			if err != nil {
				return fmt.Errorf("invalid amount format: %w", err)
			}
			if amount.LessThanOrEqual(decimal.Zero) {
				return fmt.Errorf("amount must be greater than zero")
			}
			params.Amount = toNumeric(amount)
		} else {
			params.Amount = existing.Amount
		}

		// Update interval if provided
		if req.IntervalValue != nil {
			params.IntervalValue = int32(*req.IntervalValue)
		} else {
			params.IntervalValue = existing.IntervalValue
		}

		if req.IntervalUnit != nil {
			params.IntervalUnit = string(*req.IntervalUnit)
		} else {
			params.IntervalUnit = existing.IntervalUnit
		}

		// Update payment method if provided
		if req.PaymentMethodID != nil {
			pmID, err := uuid.Parse(*req.PaymentMethodID)
			if err != nil {
				return fmt.Errorf("invalid payment_method_id format: %w", err)
			}

			// Verify payment method exists and belongs to customer
			pm, err := q.GetPaymentMethodByID(ctx, pmID)
			if err != nil {
				return fmt.Errorf("payment method not found: %w", err)
			}

			if pm.AgentID != existing.AgentID || pm.CustomerID != existing.CustomerID {
				return fmt.Errorf("payment method does not belong to customer")
			}

			if !pm.IsActive.Valid || !pm.IsActive.Bool {
				return fmt.Errorf("payment method is not active")
			}

			params.PaymentMethodID = pmID
		} else {
			params.PaymentMethodID = existing.PaymentMethodID
		}

		dbSub, err := q.UpdateSubscription(ctx, params)
		if err != nil {
			return fmt.Errorf("failed to update subscription: %w", err)
		}

		subscription = sqlcSubscriptionToDomain(&dbSub)
		return nil
	})

	if err != nil {
		return nil, err
	}

	s.logger.Info("Subscription updated",
		zap.String("subscription_id", subscription.ID),
	)

	return subscription, nil
}

// CancelSubscription cancels an active subscription
func (s *Service) CancelSubscription(ctx context.Context, req ports.ServiceCancelSubscriptionRequest) (*ports.ServiceSubscriptionResponse, error) {
	subID, err := uuid.Parse(req.SubscriptionID)
	if err != nil {
		return nil, fmt.Errorf("invalid subscription ID: %w", err)
	}

	subscription, err := s.subRepo.GetByID(ctx, nil, subID)
	if err != nil {
		return nil, fmt.Errorf("get subscription: %w", err)
	}

	// Validate subscription can be cancelled
	if subscription.Status == models.SubStatusCancelled {
		return nil, fmt.Errorf("subscription already cancelled")
	}

	var response *ports.ServiceSubscriptionResponse

	err = s.db.WithTransaction(ctx, func(ctx context.Context, tx pgx.Tx) error {
		now := time.Now()
		subscription.Status = models.SubStatusCancelled
		subscription.CancelledAt = &now
		subscription.UpdatedAt = now

		if err := s.subRepo.Update(ctx, tx, subscription); err != nil {
			return fmt.Errorf("update subscription: %w", err)
		}

		// Cancel gateway subscription if exists
		if s.recurringGateway != nil && subscription.GatewaySubscriptionID != "" {
			_, err := s.recurringGateway.CancelSubscription(ctx, subscription.GatewaySubscriptionID, true)
			if err != nil {
				s.logger.Warn("gateway subscription cancellation failed",
					ports.String("subscription_id", subscription.ID),
					ports.String("error", err.Error()))
			}
		}

		response = s.toSubscriptionResponse(subscription)
		return nil
	})

	if err != nil {
		s.logger.Error("cancel subscription failed",
			ports.String("subscription_id", req.SubscriptionID),
			ports.String("error", err.Error()))
		return nil, err
	}

	s.logger.Info("subscription cancelled",
		ports.String("subscription_id", subscription.ID),
		ports.String("reason", req.Reason))

	return response, nil
}

// PauseSubscription pauses an active subscription
func (s *Service) PauseSubscription(ctx context.Context, subscriptionID string) (*ports.ServiceSubscriptionResponse, error) {
	subID, err := uuid.Parse(subscriptionID)
	if err != nil {
		return nil, fmt.Errorf("invalid subscription ID: %w", err)
	}

	subscription, err := s.subRepo.GetByID(ctx, nil, subID)
	if err != nil {
		return nil, fmt.Errorf("get subscription: %w", err)
	}

	if subscription.Status != models.SubStatusActive {
		return nil, fmt.Errorf("can only pause active subscriptions")
	}

	var response *ports.ServiceSubscriptionResponse

	err = s.db.WithTransaction(ctx, func(ctx context.Context, tx pgx.Tx) error {
		subscription.Status = models.SubStatusPaused
		subscription.UpdatedAt = time.Now()

		if err := s.subRepo.Update(ctx, tx, subscription); err != nil {
			return fmt.Errorf("update subscription: %w", err)
		}

		// Pause gateway subscription if exists
		if s.recurringGateway != nil && subscription.GatewaySubscriptionID != "" {
			_, err := s.recurringGateway.PauseSubscription(ctx, subscription.GatewaySubscriptionID)
			if err != nil {
				s.logger.Warn("gateway subscription pause failed",
					ports.String("subscription_id", subscription.ID),
					ports.String("error", err.Error()))
			}
		}

		response = s.toSubscriptionResponse(subscription)
		return nil
	})

	if err != nil {
		s.logger.Error("pause subscription failed",
			ports.String("subscription_id", subscriptionID),
			ports.String("error", err.Error()))
		return nil, err
	}

	s.logger.Info("subscription paused",
		ports.String("subscription_id", subscription.ID))

	return response, nil
}

// ResumeSubscription resumes a paused subscription
func (s *Service) ResumeSubscription(ctx context.Context, subscriptionID string) (*ports.ServiceSubscriptionResponse, error) {
	subID, err := uuid.Parse(subscriptionID)
	if err != nil {
		return nil, fmt.Errorf("invalid subscription ID: %w", err)
	}

	subscription, err := s.subRepo.GetByID(ctx, nil, subID)
	if err != nil {
		return nil, fmt.Errorf("get subscription: %w", err)
	}

	if subscription.Status != models.SubStatusPaused {
		return nil, fmt.Errorf("can only resume paused subscriptions")
	}

	var response *ports.ServiceSubscriptionResponse

	err = s.db.WithTransaction(ctx, func(ctx context.Context, tx pgx.Tx) error {
		subscription.Status = models.SubStatusActive
		subscription.UpdatedAt = time.Now()
		// Recalculate next billing date from now
		subscription.NextBillingDate = s.calculateNextBillingDate(time.Now(), subscription.Frequency)

		if err := s.subRepo.Update(ctx, tx, subscription); err != nil {
			return fmt.Errorf("update subscription: %w", err)
		}

		// Resume gateway subscription if exists
		if s.recurringGateway != nil && subscription.GatewaySubscriptionID != "" {
			_, err := s.recurringGateway.ResumeSubscription(ctx, subscription.GatewaySubscriptionID)
			if err != nil {
				s.logger.Warn("gateway subscription resume failed",
					ports.String("subscription_id", subscription.ID),
					ports.String("error", err.Error()))
			}
		}

		response = s.toSubscriptionResponse(subscription)
		return nil
	})

	if err != nil {
		s.logger.Error("resume subscription failed",
			ports.String("subscription_id", subscriptionID),
			ports.String("error", err.Error()))
		return nil, err
	}

	s.logger.Info("subscription resumed",
		ports.String("subscription_id", subscription.ID),
		ports.String("next_billing", subscription.NextBillingDate.Format(time.RFC3339)))

	return response, nil
}

// GetSubscription retrieves a subscription by ID
func (s *Service) GetSubscription(ctx context.Context, subscriptionID string) (*models.Subscription, error) {
	subID, err := uuid.Parse(subscriptionID)
	if err != nil {
		return nil, fmt.Errorf("invalid subscription ID: %w", err)
	}

	return s.subRepo.GetByID(ctx, nil, subID)
}

// ListCustomerSubscriptions lists all subscriptions for a customer
func (s *Service) ListCustomerSubscriptions(ctx context.Context, merchantID, customerID string) ([]*models.Subscription, error) {
	return s.subRepo.ListByCustomer(ctx, nil, merchantID, customerID)
}

// ProcessDueBilling processes all subscriptions due for billing
func (s *Service) ProcessDueBilling(ctx context.Context, asOfDate time.Time, batchSize int) (*ports.BillingBatchResult, error) {
	result := &ports.BillingBatchResult{
		Errors: make([]ports.BillingError, 0),
	}

	// Get subscriptions due for billing
	subscriptions, err := s.subRepo.ListActiveSubscriptionsDueForBilling(ctx, nil, asOfDate, int32(batchSize))
	if err != nil {
		return nil, fmt.Errorf("list subscriptions due for billing: %w", err)
	}

	result.ProcessedCount = len(subscriptions)

	s.logger.Info("processing billing batch",
		ports.String("as_of_date", asOfDate.Format(time.RFC3339)),
		ports.String("count", fmt.Sprintf("%d", len(subscriptions))))

	// Process each subscription
	for _, sub := range subscriptions {
		err := s.processSingleBilling(ctx, sub)
		if err != nil {
			result.FailedCount++
			result.Errors = append(result.Errors, ports.BillingError{
				SubscriptionID: sub.ID,
				CustomerID:     sub.CustomerID,
				Error:          err.Error(),
				Retriable:      true,
			})
			s.logger.Error("billing failed for subscription",
				ports.String("subscription_id", sub.ID),
				ports.String("customer_id", sub.CustomerID),
				ports.String("error", err.Error()))
		} else {
			result.SuccessCount++
		}
	}

	s.logger.Info("billing batch completed",
		ports.String("processed", fmt.Sprintf("%d", result.ProcessedCount)),
		ports.String("success", fmt.Sprintf("%d", result.SuccessCount)),
		ports.String("failed", fmt.Sprintf("%d", result.FailedCount)))

	return result, nil
}

// processSingleBilling processes billing for a single subscription
func (s *Service) processSingleBilling(ctx context.Context, sub *models.Subscription) error {
	// Charge the customer using Payment Service
	saleReq := ports.ServiceSaleRequest{
		MerchantID: sub.MerchantID,
		CustomerID: sub.CustomerID,
		Amount:     sub.Amount,
		Currency:   sub.Currency,
		Token:      sub.PaymentMethodToken,
		BillingInfo: models.BillingInfo{}, // Subscription already has customer info
		IdempotencyKey: fmt.Sprintf("sub-%s-%s", sub.ID, sub.NextBillingDate.Format("2006-01-02")),
		Metadata: map[string]string{
			"subscription_id":   sub.ID,
			"billing_period":    sub.NextBillingDate.Format("2006-01-02"),
			"billing_frequency": string(sub.Frequency),
		},
	}

	paymentResp, err := s.paymentService.Sale(ctx, saleReq)
	if err != nil || (paymentResp != nil && !paymentResp.IsApproved) {
		// Update subscription failure state
		updateErr := s.handleBillingFailure(ctx, sub, err)
		if updateErr != nil {
			return fmt.Errorf("payment failed and failed to update subscription: %w", updateErr)
		}
		// Return the original payment error so ProcessDueBilling counts this as failed
		if err != nil {
			return fmt.Errorf("payment failed: %w", err)
		}
		return fmt.Errorf("payment declined")
	}

	// Billing successful - update subscription
	return s.handleBillingSuccess(ctx, sub)
}

// handleBillingSuccess updates subscription after successful billing
func (s *Service) handleBillingSuccess(ctx context.Context, sub *models.Subscription) error {
	return s.db.WithTransaction(ctx, func(ctx context.Context, tx pgx.Tx) error {
		// Reset failure count
		sub.FailureRetryCount = 0
		// Calculate next billing date
		sub.NextBillingDate = s.calculateNextBillingDate(sub.NextBillingDate, sub.Frequency)
		sub.UpdatedAt = time.Now()

		return s.subRepo.Update(ctx, tx, sub)
	})
}

// handleBillingFailure handles subscription billing failures
func (s *Service) handleBillingFailure(ctx context.Context, sub *models.Subscription, billingErr error) error {
	return s.db.WithTransaction(ctx, func(ctx context.Context, tx pgx.Tx) error {
		sub.FailureRetryCount++
		sub.UpdatedAt = time.Now()

		// Check if max retries exceeded
		if sub.FailureRetryCount >= sub.MaxRetries {
			switch sub.FailureOption {
			case models.FailureForward:
				// Move billing date forward
				sub.NextBillingDate = s.calculateNextBillingDate(sub.NextBillingDate, sub.Frequency)
				sub.FailureRetryCount = 0 // Reset for next period
			case models.FailureSkip:
				// Skip this billing cycle
				sub.NextBillingDate = s.calculateNextBillingDate(sub.NextBillingDate, sub.Frequency)
				sub.FailureRetryCount = 0
			case models.FailurePause:
				// Pause subscription
				sub.Status = models.SubStatusPaused
			}
		}

		return s.subRepo.Update(ctx, tx, sub)
	})
}

// calculateNextBillingDate calculates the next billing date based on frequency
func (s *Service) calculateNextBillingDate(fromDate time.Time, frequency models.BillingFrequency) time.Time {
	switch frequency {
	case models.FrequencyWeekly:
		return fromDate.AddDate(0, 0, 7)
	case models.FrequencyBiWeekly:
		return fromDate.AddDate(0, 0, 14)
	case models.FrequencyMonthly:
		return fromDate.AddDate(0, 1, 0)
	case models.FrequencyYearly:
		return fromDate.AddDate(1, 0, 0)
	default:
		return fromDate.AddDate(0, 1, 0) // Default to monthly
	}
}

// toSubscriptionResponse converts a subscription model to a response
func (s *Service) toSubscriptionResponse(sub *models.Subscription) *ports.ServiceSubscriptionResponse {
	return &ports.ServiceSubscriptionResponse{
		SubscriptionID:        sub.ID,
		MerchantID:            sub.MerchantID,
		CustomerID:            sub.CustomerID,
		Amount:                sub.Amount,
		Currency:              sub.Currency,
		Frequency:             sub.Frequency,
		Status:                sub.Status,
		PaymentMethodToken:    sub.PaymentMethodToken,
		NextBillingDate:       sub.NextBillingDate,
		GatewaySubscriptionID: sub.GatewaySubscriptionID,
		CreatedAt:             sub.CreatedAt,
		UpdatedAt:             sub.UpdatedAt,
		CancelledAt:           sub.CancelledAt,
	}
}
